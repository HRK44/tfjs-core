{"dependencies":[{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/float16/tfjs-core/test/package.json","includedInParent":true,"mtime":1528810356568},{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/float16/tfjs-core/test/.babelrc","includedInParent":true,"mtime":1525096773813},{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/float16/tfjs-core/tsconfig.json","includedInParent":true,"mtime":1528810356568},{"name":"../ops/ops","loc":{"line":38,"column":20}},{"name":"../util","loc":{"line":39,"column":19}},{"name":"./types","loc":{"line":40,"column":22}}],"generated":{"js":"\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [0, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ops_1 = require(\"../ops/ops\");\nvar util = require(\"../util\");\nvar types_1 = require(\"./types\");\nfunction loadWeightsAsArrayBuffer(fetchURLs, requestOptions) {\n    return __awaiter(this, void 0, void 0, function () {\n        var requests, responses, buffers;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    requests = fetchURLs.map(function (fetchURL) { return fetch(fetchURL, requestOptions); });\n                    return [4, Promise.all(requests)];\n                case 1:\n                    responses = _a.sent();\n                    return [4, Promise.all(responses.map(function (response) { return response.arrayBuffer(); }))];\n                case 2:\n                    buffers = _a.sent();\n                    return [2, buffers];\n            }\n        });\n    });\n}\nexports.loadWeightsAsArrayBuffer = loadWeightsAsArrayBuffer;\nfunction loadWeights(manifest, filePathPrefix, weightNames, requestOptions) {\n    if (filePathPrefix === void 0) { filePathPrefix = ''; }\n    return __awaiter(this, void 0, void 0, function () {\n        var groupIndicesToFetchMap, groupWeightsToFetch, weightsFound, allManifestWeightNames, weightsNotFound, groupIndicesToFetch, fetchUrls, buffers, weightsTensorMap, bufferIndexOffset;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    groupIndicesToFetchMap = manifest.map(function () { return false; });\n                    groupWeightsToFetch = {};\n                    weightsFound = weightNames != null ? weightNames.map(function () { return false; }) : [];\n                    allManifestWeightNames = [];\n                    manifest.forEach(function (manifestGroupConfig, groupIndex) {\n                        var groupOffset = 0;\n                        manifestGroupConfig.weights.forEach(function (weightsEntry) {\n                            var rawDtype = ('quantization' in weightsEntry) ?\n                                weightsEntry.quantization.dtype :\n                                weightsEntry.dtype;\n                            var weightsBytes = types_1.DTYPE_VALUE_SIZE_MAP[rawDtype] *\n                                util.sizeFromShape(weightsEntry.shape);\n                            var enqueueWeightsForFetchingFn = function () {\n                                groupIndicesToFetchMap[groupIndex] = true;\n                                if (groupWeightsToFetch[groupIndex] == null) {\n                                    groupWeightsToFetch[groupIndex] = [];\n                                }\n                                groupWeightsToFetch[groupIndex].push({\n                                    manifestEntry: weightsEntry,\n                                    groupOffset: groupOffset,\n                                    sizeBytes: weightsBytes\n                                });\n                            };\n                            if (weightNames != null) {\n                                weightNames.forEach(function (weightName, weightIndex) {\n                                    if (weightName === weightsEntry.name) {\n                                        enqueueWeightsForFetchingFn();\n                                        weightsFound[weightIndex] = true;\n                                    }\n                                });\n                            }\n                            else {\n                                enqueueWeightsForFetchingFn();\n                            }\n                            allManifestWeightNames.push(weightsEntry.name);\n                            groupOffset += weightsBytes;\n                        });\n                    });\n                    if (!weightsFound.every(function (found) { return found; })) {\n                        weightsNotFound = weightNames.filter(function (weight, i) { return !weightsFound[i]; });\n                        throw new Error(\"Could not find weights in manifest with names: \" +\n                            (weightsNotFound.join(', ') + \". \\n\") +\n                            \"Manifest JSON has weights with names: \" +\n                            (allManifestWeightNames.join(', ') + \".\"));\n                    }\n                    groupIndicesToFetch = groupIndicesToFetchMap.reduce(function (accumulator, shouldFetch, i) {\n                        if (shouldFetch) {\n                            accumulator.push(i);\n                        }\n                        return accumulator;\n                    }, []);\n                    fetchUrls = [];\n                    groupIndicesToFetch.forEach(function (i) {\n                        manifest[i].paths.forEach(function (filepath) {\n                            var fetchUrl = filePathPrefix +\n                                (!filePathPrefix.endsWith('/') ? '/' : '') + filepath;\n                            fetchUrls.push(fetchUrl);\n                        });\n                    });\n                    return [4, loadWeightsAsArrayBuffer(fetchUrls, requestOptions)];\n                case 1:\n                    buffers = _a.sent();\n                    weightsTensorMap = {};\n                    bufferIndexOffset = 0;\n                    groupIndicesToFetch.forEach(function (i) {\n                        var numBuffers = manifest[i].paths.length;\n                        var groupBytes = 0;\n                        for (var i_1 = 0; i_1 < numBuffers; i_1++) {\n                            groupBytes += buffers[bufferIndexOffset + i_1].byteLength;\n                        }\n                        var groupBuffer = new ArrayBuffer(groupBytes);\n                        var groupByteBuffer = new Uint8Array(groupBuffer);\n                        var groupBufferOffset = 0;\n                        for (var i_2 = 0; i_2 < numBuffers; i_2++) {\n                            var buffer = new Uint8Array(buffers[bufferIndexOffset + i_2]);\n                            groupByteBuffer.set(buffer, groupBufferOffset);\n                            groupBufferOffset += buffer.byteLength;\n                        }\n                        var weightsEntries = groupWeightsToFetch[i];\n                        weightsEntries.forEach(function (weightsEntry) {\n                            var byteBuffer = groupBuffer.slice(weightsEntry.groupOffset, weightsEntry.groupOffset + weightsEntry.sizeBytes);\n                            var typedArray;\n                            var dtype = weightsEntry.manifestEntry.dtype;\n                            if ('quantization' in weightsEntry.manifestEntry) {\n                                var quantization_1 = weightsEntry.manifestEntry.quantization;\n                                if (quantization_1.dtype !== 'uint8' && quantization_1.dtype !== 'uint16') {\n                                    throw new Error(\"Weight \" + weightsEntry.manifestEntry.name + \" has unknown \" +\n                                        (\"quantization dtype \" + quantization_1.dtype + \".\"));\n                                }\n                                var quantizedArray = (quantization_1.dtype === 'uint8') ?\n                                    new Uint8Array(byteBuffer) :\n                                    new Uint16Array(byteBuffer);\n                                if (dtype === 'float32') {\n                                    typedArray = Float32Array.from(quantizedArray, function (v) { return v * quantization_1.scale + quantization_1.min; });\n                                }\n                                else if (dtype === 'int32') {\n                                    typedArray = Int32Array.from(quantizedArray, function (v) { return Math.round(v * quantization_1.scale + quantization_1.min); });\n                                }\n                                else {\n                                    throw new Error(\"Weight \" + weightsEntry.manifestEntry.name + \" has a dtype not \" +\n                                        (\"supported by quantization: \" + dtype));\n                                }\n                            }\n                            else {\n                                if (dtype === 'float32') {\n                                    typedArray = new Float32Array(byteBuffer);\n                                }\n                                else if (dtype === 'int32') {\n                                    typedArray = new Int32Array(byteBuffer);\n                                }\n                                else {\n                                    throw new Error(\"Weight \" + weightsEntry.manifestEntry.name + \" has unknown dtype \" +\n                                        (dtype + \".\"));\n                                }\n                            }\n                            var weightName = weightsEntry.manifestEntry.name;\n                            if (weightsTensorMap[weightName] != null) {\n                                throw new Error(\"Duplicate weight with name \" + weightName + \". \" +\n                                    \"Please make sure weights names are unique in the manifest JSON.\");\n                            }\n                            weightsTensorMap[weightName] = ops_1.tensor(typedArray, weightsEntry.manifestEntry.shape, weightsEntry.manifestEntry.dtype);\n                        });\n                        bufferIndexOffset += numBuffers;\n                    });\n                    return [2, weightsTensorMap];\n            }\n        });\n    });\n}\nexports.loadWeights = loadWeights;\n","map":{"version":3,"file":"weights_loader.js","sourceRoot":"","sources":["../src/io/weights_loader.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n// tslint:disable:max-line-length\nimport {tensor} from '../ops/ops';\nimport {NamedTensorMap} from '../types';\nimport * as util from '../util';\nimport {DTYPE_VALUE_SIZE_MAP, WeightsManifestConfig, WeightsManifestEntry} from './types';\n// tslint:enable:max-line-length\n\n/**\n * Reads binary weights data from a number of URLs.\n *\n * @param fetchURLs URLs to send the HTTP requests at, using `fetch` calls.\n * @param requestOptions RequestInit (options) for the HTTP requests.\n * @returns A `Promise` of an Array of `ArrayBuffer`. The Array has the same\n *   length as `fetchURLs`.\n */\nexport async function loadWeightsAsArrayBuffer(\n    fetchURLs: string[], requestOptions?: RequestInit): Promise<ArrayBuffer[]> {\n  // Create the requests for all of the weights in parallel.\n  const requests = fetchURLs.map(fetchURL => fetch(fetchURL, requestOptions));\n  const responses = await Promise.all(requests);\n  const buffers =\n      await Promise.all(responses.map(response => response.arrayBuffer()));\n  return buffers;\n}\n\n/**\n * Reads a weights manifest JSON configuration, fetches the weights and\n * returns them as `Tensor`s.\n *\n * @param manifest The weights manifest JSON.\n * @param filePathPrefix The path prefix for filenames given in the manifest.\n *     Defaults to the empty string.\n * @param weightNames The names of the weights to be fetched.\n */\nexport async function loadWeights(\n    manifest: WeightsManifestConfig, filePathPrefix = '',\n    weightNames?: string[],\n    requestOptions?: RequestInit): Promise<NamedTensorMap> {\n  // TODO(nsthorat): Groups are currently fetched atomically. If you need a\n  // single weight from a group, the whole group will be fetched. At a future\n  // date, we should support fetching only the individual shards within a\n  // group that are needed to reconstruct the requested weight.\n  // TODO(cais): Use `decodeWeights` for implementation.\n\n  // Collect all the groups, weights, and their relative offsets to be\n  // fetched.\n  const groupIndicesToFetchMap = manifest.map(() => false);\n  const groupWeightsToFetch: {\n    [group: number]: Array<{\n      manifestEntry: WeightsManifestEntry; groupOffset: number;\n      sizeBytes: number;\n    }>\n  } = {};\n  const weightsFound = weightNames != null ? weightNames.map(() => false) : [];\n  const allManifestWeightNames: string[] = [];\n  manifest.forEach((manifestGroupConfig, groupIndex) => {\n    let groupOffset = 0;\n    manifestGroupConfig.weights.forEach(weightsEntry => {\n      const rawDtype = ('quantization' in weightsEntry) ?\n          weightsEntry.quantization.dtype :\n          weightsEntry.dtype;\n\n      const weightsBytes = DTYPE_VALUE_SIZE_MAP[rawDtype] *\n          util.sizeFromShape(weightsEntry.shape);\n\n      const enqueueWeightsForFetchingFn = () => {\n        groupIndicesToFetchMap[groupIndex] = true;\n        if (groupWeightsToFetch[groupIndex] == null) {\n          groupWeightsToFetch[groupIndex] = [];\n        }\n\n        groupWeightsToFetch[groupIndex].push({\n          manifestEntry: weightsEntry,\n          groupOffset,\n          sizeBytes: weightsBytes\n        });\n      };\n\n      if (weightNames != null) {\n        weightNames.forEach((weightName, weightIndex) => {\n          if (weightName === weightsEntry.name) {\n            enqueueWeightsForFetchingFn();\n            weightsFound[weightIndex] = true;\n          }\n        });\n      } else {\n        enqueueWeightsForFetchingFn();\n      }\n\n      allManifestWeightNames.push(weightsEntry.name);\n      groupOffset += weightsBytes;\n    });\n  });\n\n  if (!weightsFound.every(found => found)) {\n    const weightsNotFound = weightNames.filter((weight, i) => !weightsFound[i]);\n    throw new Error(\n        `Could not find weights in manifest with names: ` +\n        `${weightsNotFound.join(', ')}. \\n` +\n        `Manifest JSON has weights with names: ` +\n        `${allManifestWeightNames.join(', ')}.`);\n  }\n\n  // Convert the one-hot boolean groupId => shouldFetch map to a list of group\n  // IDs.\n  const groupIndicesToFetch =\n      groupIndicesToFetchMap.reduce((accumulator, shouldFetch, i) => {\n        if (shouldFetch) {\n          accumulator.push(i);\n        }\n        return accumulator;\n      }, []);\n\n  const fetchUrls: string[] = [];\n  groupIndicesToFetch.forEach(i => {\n    manifest[i].paths.forEach(filepath => {\n      const fetchUrl = filePathPrefix +\n          (!filePathPrefix.endsWith('/') ? '/' : '') + filepath;\n      fetchUrls.push(fetchUrl);\n    });\n  });\n  const buffers = await loadWeightsAsArrayBuffer(fetchUrls, requestOptions);\n\n  const weightsTensorMap: NamedTensorMap = {};\n  let bufferIndexOffset = 0;\n  groupIndicesToFetch.forEach(i => {\n    const numBuffers = manifest[i].paths.length;\n\n    let groupBytes = 0;\n    for (let i = 0; i < numBuffers; i++) {\n      groupBytes += buffers[bufferIndexOffset + i].byteLength;\n    }\n\n    // Create a buffer for the whole group.\n    const groupBuffer = new ArrayBuffer(groupBytes);\n    const groupByteBuffer = new Uint8Array(groupBuffer);\n    let groupBufferOffset = 0;\n    for (let i = 0; i < numBuffers; i++) {\n      const buffer = new Uint8Array(buffers[bufferIndexOffset + i]);\n      groupByteBuffer.set(buffer, groupBufferOffset);\n      groupBufferOffset += buffer.byteLength;\n    }\n\n    const weightsEntries = groupWeightsToFetch[i];\n\n    weightsEntries.forEach(weightsEntry => {\n      const byteBuffer = groupBuffer.slice(\n          weightsEntry.groupOffset,\n          weightsEntry.groupOffset + weightsEntry.sizeBytes);\n\n      let typedArray: Float32Array|Int32Array;\n\n      const dtype = weightsEntry.manifestEntry.dtype;\n\n      if ('quantization' in weightsEntry.manifestEntry) {\n        const quantization = weightsEntry.manifestEntry.quantization;\n        if (quantization.dtype !== 'uint8' && quantization.dtype !== 'uint16') {\n          throw new Error(\n              `Weight ${weightsEntry.manifestEntry.name} has unknown ` +\n              `quantization dtype ${quantization.dtype}.`);\n        }\n        const quantizedArray = (quantization.dtype === 'uint8') ?\n            new Uint8Array(byteBuffer) :\n            new Uint16Array(byteBuffer);\n        if (dtype === 'float32') {\n          typedArray = Float32Array.from(\n              quantizedArray, v => v * quantization.scale + quantization.min);\n        } else if (dtype === 'int32') {\n          typedArray = Int32Array.from(\n              quantizedArray,\n              v => Math.round(v * quantization.scale + quantization.min));\n        } else {\n          throw new Error(\n              `Weight ${weightsEntry.manifestEntry.name} has a dtype not ` +\n              `supported by quantization: ${dtype}`);\n        }\n      } else {\n        if (dtype === 'float32') {\n          typedArray = new Float32Array(byteBuffer);\n        } else if (dtype === 'int32') {\n          typedArray = new Int32Array(byteBuffer);\n        } else {\n          throw new Error(\n              `Weight ${weightsEntry.manifestEntry.name} has unknown dtype ` +\n              `${dtype}.`);\n        }\n      }\n\n      const weightName = weightsEntry.manifestEntry.name;\n      if (weightsTensorMap[weightName] != null) {\n        throw new Error(\n            `Duplicate weight with name ${weightName}. ` +\n            `Please make sure weights names are unique in the manifest JSON.`);\n      }\n      weightsTensorMap[weightName] = tensor(\n          typedArray, weightsEntry.manifestEntry.shape,\n          weightsEntry.manifestEntry.dtype);\n    });\n\n    bufferIndexOffset += numBuffers;\n  });\n\n  return weightsTensorMap;\n}\n"]}},"hash":"b40331786e2c6287d74c1c0fe9f792b2","cacheData":{"env":{}}}