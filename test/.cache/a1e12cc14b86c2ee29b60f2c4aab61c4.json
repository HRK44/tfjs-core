{"dependencies":[{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/float16/tfjs-core/test/package.json","includedInParent":true,"mtime":1525096773813},{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/float16/tfjs-core/test/.babelrc","includedInParent":true,"mtime":1525096773813},{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/float16/tfjs-core/tsconfig.json","includedInParent":true,"mtime":1524062920943},{"name":"../doc","loc":{"line":9,"column":20}},{"name":"../environment","loc":{"line":10,"column":28}},{"name":"../util","loc":{"line":11,"column":19}},{"name":"./conv_util","loc":{"line":12,"column":24}},{"name":"./operation","loc":{"line":13,"column":26}}],"generated":{"js":"\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar doc_1 = require(\"../doc\");\nvar environment_1 = require(\"../environment\");\nvar util = require(\"../util\");\nvar conv_util = require(\"./conv_util\");\nvar operation_1 = require(\"./operation\");\nvar ConvOps = (function () {\n    function ConvOps() {\n    }\n    ConvOps.conv1d = function (x, filter, stride, pad, dataFormat, dilation, dimRoundingMode) {\n        if (dataFormat === void 0) { dataFormat = 'NWC'; }\n        if (dilation === void 0) { dilation = 1; }\n        util.assertArgumentsAreTensors({ x: x, filter: filter }, 'conv1d');\n        var x3D = x;\n        var reshapedTo3D = false;\n        if (x.rank === 2) {\n            reshapedTo3D = true;\n            x3D = x.as3D(1, x.shape[0], x.shape[1]);\n        }\n        util.assert(x3D.rank === 3, \"Error in conv1d: input must be rank 3, but got rank \" + x3D.rank + \".\");\n        util.assert(filter.rank === 3, \"Error in conv1d: filter must be rank 3, but got rank \" +\n            (filter.rank + \".\"));\n        if (dimRoundingMode != null) {\n            util.assert(util.isInt(pad), \"Error in conv1d: pad must be an integer when using, \" +\n                (\"dimRoundingMode \" + dimRoundingMode + \" but got pad \" + pad + \".\"));\n        }\n        util.assert(x3D.shape[2] === filter.shape[1], \"Error in conv1d: depth of input (\" + x3D.shape[2] + \") must match  \" +\n            (\"input depth for filter \" + filter.shape[1] + \".\"));\n        util.assert(eitherStridesOrDilationsAreOne(stride, dilation), 'Error in conv1D: Either stride or dilation must be 1.' +\n            (\"Got stride \" + stride + \" and dilation '\" + dilation + \"'\"));\n        util.assert(dataFormat === 'NWC', \"Error in conv1d: got dataFormat of \" + dataFormat + \" but only NWC is currently supported.\");\n        var filter4D = filter.as4D(1, filter.shape[0], filter.shape[1], filter.shape[2]);\n        var input4D = x3D.as4D(x3D.shape[0], 1, x3D.shape[1], x3D.shape[2]);\n        var strides = [1, stride];\n        var dilations = [1, dilation];\n        var conv2dDataFormat = 'NHWC';\n        var res = ConvOps.conv2d(input4D, filter4D, strides, pad, conv2dDataFormat, dilations, dimRoundingMode);\n        if (reshapedTo3D) {\n            return res.as2D(res.shape[2], res.shape[3]);\n        }\n        return res.as3D(res.shape[0], res.shape[2], res.shape[3]);\n    };\n    ConvOps.conv2d = function (x, filter, strides, pad, dataFormat, dilations, dimRoundingMode) {\n        if (dataFormat === void 0) { dataFormat = 'NHWC'; }\n        if (dilations === void 0) { dilations = [1, 1]; }\n        util.assertArgumentsAreTensors({ x: x, filter: filter }, 'conv2d');\n        var x4D = x;\n        var reshapedTo4D = false;\n        if (x.rank === 3) {\n            reshapedTo4D = true;\n            x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);\n        }\n        util.assert(x4D.rank === 4, \"Error in conv2d: input must be rank 4, but got rank \" + x4D.rank + \".\");\n        util.assert(filter.rank === 4, \"Error in conv2d: filter must be rank 4, but got rank \" +\n            (filter.rank + \".\"));\n        if (dimRoundingMode != null) {\n            util.assert(util.isInt(pad), \"Error in conv2d: pad must be an integer when using, \" +\n                (\"dimRoundingMode \" + dimRoundingMode + \" but got pad \" + pad + \".\"));\n        }\n        util.assert(x4D.shape[3] === filter.shape[2], \"Error in conv2d: depth of input (\" + x4D.shape[3] + \") must match  \" +\n            (\"input depth for filter \" + filter.shape[2] + \".\"));\n        util.assert(eitherStridesOrDilationsAreOne(strides, dilations), 'Error in conv2D: Either strides or dilations must be 1.' +\n            (\"Got strides \" + strides + \" and dilations '\" + dilations + \"'\"));\n        util.assert(dataFormat === 'NHWC', \"Error in conv2d: got dataFormat of \" + dataFormat + \" but only NHWC is currently supported.\");\n        var convInfo = conv_util.computeConv2DInfo(x4D.shape, filter.shape, strides, dilations, pad, dimRoundingMode);\n        var grad = function (dy) {\n            util.assert(tupleValuesAreOne(dilations), 'Error in gradient of conv2D: dilation rates greater than 1 are not' +\n                (\"yet supported in gradients. Got dilations '\" + dilations + \"'\"));\n            return {\n                x: function () { return ConvOps.conv2dDerInput(x4D.shape, dy, filter, strides, pad); },\n                filter: function () {\n                    return ConvOps.conv2dDerFilter(x4D, dy, filter.shape, strides, pad);\n                }\n            };\n        };\n        var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.conv2d(x4D, filter, convInfo); }, { x: x4D, filter: filter }, grad);\n        if (reshapedTo4D) {\n            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);\n        }\n        return res;\n    };\n    ConvOps.conv2dDerInput = function (xShape, dy, filter, strides, pad, dimRoundingMode) {\n        util.assertArgumentsAreTensors({ dy: dy, filter: filter }, 'conv2dDerInput');\n        util.assert(xShape.length === dy.rank, \"Length of inShape \" +\n            (\"(\" + xShape.length + \") and rank of dy (\" + dy.rank + \") must match\"));\n        var xShape4D = xShape;\n        var dy4D = dy;\n        var reshapedTo4D = false;\n        if (dy.rank === 3) {\n            reshapedTo4D = true;\n            dy4D = dy.as4D(1, dy.shape[0], dy.shape[1], dy.shape[2]);\n            xShape4D = [1, xShape[0], xShape[1], xShape[2]];\n        }\n        var inDepth = xShape4D[3];\n        var outDepth = dy4D.shape[3];\n        util.assert(xShape4D.length === 4, \"Error in conv2dDerInput: inShape must be length 4, but got length \" +\n            (xShape4D.length + \".\"));\n        util.assert(dy4D.rank === 4, \"Error in conv2dDerInput: dy must be rank 4, but got \" +\n            (\"rank \" + dy4D.rank));\n        util.assert(filter.rank === 4, \"Error in conv2dDerInput: filter must be rank 4, but got \" +\n            (\"rank \" + filter.rank));\n        util.assert(inDepth === filter.shape[2], \"Error in conv2dDerInput: depth of input (\" + inDepth + \") must \" +\n            (\"match input depth for filter \" + filter.shape[2] + \".\"));\n        util.assert(outDepth === filter.shape[3], \"Error in conv2dDerInput: depth of output (\" + outDepth + \") must\" +\n            (\"match output depth for filter \" + filter.shape[3] + \".\"));\n        if (dimRoundingMode != null) {\n            util.assert(util.isInt(pad), \"Error in conv2dDerInput: pad must be an integer when using, \" +\n                (\"dimRoundingMode \" + dimRoundingMode + \" but got pad \" + pad + \".\"));\n        }\n        var dilations = 1;\n        var convInfo = conv_util.computeConv2DInfo(xShape4D, filter.shape, strides, dilations, pad, dimRoundingMode);\n        var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.conv2dDerInput(dy4D, filter, convInfo); }, { dy4D: dy4D });\n        if (reshapedTo4D) {\n            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);\n        }\n        return res;\n    };\n    ConvOps.conv2dDerFilter = function (x, dy, filterShape, strides, pad, dimRoundingMode) {\n        util.assertArgumentsAreTensors({ x: x, dy: dy }, 'conv2dDerFilter');\n        var x4D = x;\n        if (x.rank === 3) {\n            x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);\n        }\n        var dy4D = dy;\n        if (dy4D.rank === 3) {\n            dy4D = dy.as4D(1, dy.shape[0], dy.shape[1], dy.shape[2]);\n        }\n        util.assert(x4D.rank === 4, \"Error in conv2dDerFilter: input must be rank 4, but got shape \" +\n            (x4D.shape + \".\"));\n        util.assert(dy4D.rank === 4, \"Error in conv2dDerFilter: dy must be rank 4, but got shape \" +\n            (dy4D.shape + \".\"));\n        util.assert(filterShape.length === 4, \"Error in conv2dDerFilter: filterShape must be length 4, but got \" +\n            (filterShape + \".\"));\n        util.assert(x4D.shape[3] === filterShape[2], \"Error in conv2dDerFilter: depth of input \" + x4D.shape[3] + \") must \" +\n            (\"match input depth in filter (\" + filterShape[2] + \".\"));\n        util.assert(dy4D.shape[3] === filterShape[3], \"Error in conv2dDerFilter: depth of dy (\" + dy4D.shape[3] + \") must \" +\n            (\"match output depth for filter (\" + filterShape[3] + \").\"));\n        if (dimRoundingMode != null) {\n            util.assert(util.isInt(pad), \"Error in conv2dDerFilter: pad must be an integer when using, \" +\n                (\"dimRoundingMode \" + dimRoundingMode + \" but got pad \" + pad + \".\"));\n        }\n        var dilations = 1;\n        var convInfo = conv_util.computeConv2DInfo(x4D.shape, filterShape, strides, dilations, pad, dimRoundingMode);\n        return environment_1.ENV.engine.runKernel(function (backend) { return backend.conv2dDerFilter(x4D, dy4D, convInfo); }, { x4D: x4D, dy4D: dy4D });\n    };\n    ConvOps.conv2dTranspose = function (x, filter, outputShape, strides, pad, dimRoundingMode) {\n        util.assertArgumentsAreTensors({ x: x, filter: filter }, 'conv2dTranspose');\n        return ConvOps.conv2dDerInput(outputShape, x, filter, strides, pad, dimRoundingMode);\n    };\n    ConvOps.depthwiseConv2d = function (x, filter, strides, pad, dataFormat, dilations, dimRoundingMode) {\n        if (dataFormat === void 0) { dataFormat = 'NHWC'; }\n        if (dilations === void 0) { dilations = [1, 1]; }\n        util.assertArgumentsAreTensors({ x: x, filter: filter }, 'depthwiseConv2d');\n        var x4D = x;\n        var reshapedTo4D = false;\n        if (x.rank === 3) {\n            reshapedTo4D = true;\n            x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);\n        }\n        util.assert(x4D.rank === 4, \"Error in depthwiseConv2D: input must be rank 4, but got \" +\n            (\"rank \" + x4D.rank + \".\"));\n        util.assert(filter.rank === 4, \"Error in depthwiseConv2D: filter must be rank 4, but got rank \" +\n            (filter.rank + \".\"));\n        util.assert(x4D.shape[3] === filter.shape[2], \"Error in depthwiseConv2D: number of input channels \" +\n            (\"(\" + x4D.shape[3] + \") must match the inChannels dimension in \") +\n            (\"filter \" + filter.shape[2] + \".\"));\n        if (dilations == null) {\n            dilations = [1, 1];\n        }\n        util.assert(eitherStridesOrDilationsAreOne(strides, dilations), 'Error in depthwiseConv2d: Either strides or dilations must be 1.' +\n            (\"Got strides \" + strides + \" and dilations '\" + dilations + \"'\"));\n        if (dimRoundingMode != null) {\n            util.assert(util.isInt(pad), \"Error in depthwiseConv2D: pad must be an integer when using, \" +\n                (\"dimRoundingMode \" + dimRoundingMode + \" but got pad \" + pad + \".\"));\n        }\n        var convInfo = conv_util.computeConv2DInfo(x4D.shape, filter.shape, strides, dilations, pad, dimRoundingMode, true);\n        var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.depthwiseConv2D(x4D, filter, convInfo); }, { x4D: x4D, filter: filter });\n        if (reshapedTo4D) {\n            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);\n        }\n        return res;\n    };\n    ConvOps.separableConv2d = function (x, depthwiseFilter, pointwiseFilter, strides, pad, dilation, dataFormat) {\n        if (dilation === void 0) { dilation = [1, 1]; }\n        if (dataFormat === void 0) { dataFormat = 'NHWC'; }\n        util.assertArgumentsAreTensors({ x: x, depthwiseFilter: depthwiseFilter, pointwiseFilter: pointwiseFilter }, 'separableConv2d');\n        var x4D = x;\n        var reshapedTo4D = false;\n        if (x.rank === 3) {\n            reshapedTo4D = true;\n            x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);\n        }\n        if (dataFormat === 'NCHW') {\n            throw new Error('separableConv2d currently does not support dataFormat NCHW; only ' +\n                'NHWC is supported');\n        }\n        util.assert(x4D.rank === 4, \"Error in separableConv2d: input must be rank 4, but got \" +\n            (\"rank \" + x4D.rank + \".\"));\n        util.assert(depthwiseFilter.rank === 4, \"Error in separableConv2d: depthwise filter must be rank 4, but got \" +\n            (\"rank \" + depthwiseFilter.rank + \".\"));\n        util.assert(pointwiseFilter.rank === 4, \"Error in separableConv2d: pointwise filter must be rank 4, but got \" +\n            (\"rank \" + depthwiseFilter.rank + \".\"));\n        util.assert(pointwiseFilter.shape[0] === 1, \"Error in separableConv2d: the first dimension of pointwise filter \" +\n            (\" must be 1, but got \" + pointwiseFilter.shape[0] + \".\"));\n        util.assert(pointwiseFilter.shape[1] === 1, \"Error in separableConv2d: the second dimension of pointwise filter \" +\n            (\" must be 1, but got \" + pointwiseFilter.shape[1] + \".\"));\n        var inChannels = depthwiseFilter.shape[2];\n        var channelMultiplier = depthwiseFilter.shape[3];\n        util.assert(pointwiseFilter.shape[2] === inChannels * channelMultiplier, \"Error in separableConv2d: the third dimension of pointwise filter \" +\n            (\"must be \" + inChannels * channelMultiplier + \", \") +\n            (\"but got \" + pointwiseFilter.shape[2] + \".\"));\n        var depthwise = ConvOps.depthwiseConv2d(x4D, depthwiseFilter, strides, pad, dataFormat, dilation);\n        var pointwiseStride = 1;\n        var res = ConvOps.conv2d(depthwise, pointwiseFilter, pointwiseStride, 'valid', dataFormat);\n        if (reshapedTo4D) {\n            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);\n        }\n        return res;\n    };\n    __decorate([\n        doc_1.doc({ heading: 'Operations', subheading: 'Convolution' }),\n        operation_1.operation\n    ], ConvOps, \"conv1d\", null);\n    __decorate([\n        doc_1.doc({ heading: 'Operations', subheading: 'Convolution' }),\n        operation_1.operation\n    ], ConvOps, \"conv2d\", null);\n    __decorate([\n        operation_1.operation\n    ], ConvOps, \"conv2dDerInput\", null);\n    __decorate([\n        operation_1.operation\n    ], ConvOps, \"conv2dDerFilter\", null);\n    __decorate([\n        doc_1.doc({ heading: 'Operations', subheading: 'Convolution' }),\n        operation_1.operation\n    ], ConvOps, \"conv2dTranspose\", null);\n    __decorate([\n        doc_1.doc({ heading: 'Operations', subheading: 'Convolution' }),\n        operation_1.operation\n    ], ConvOps, \"depthwiseConv2d\", null);\n    __decorate([\n        doc_1.doc({ heading: 'Operations', subheading: 'Convolution' }),\n        operation_1.operation\n    ], ConvOps, \"separableConv2d\", null);\n    return ConvOps;\n}());\nexports.ConvOps = ConvOps;\nfunction parseTupleParam(param) {\n    return typeof param === 'number' ? [param, param] : param;\n}\nfunction tupleValuesAreOne(param) {\n    var _a = parseTupleParam(param), dimA = _a[0], dimB = _a[1];\n    return dimA === 1 && dimB === 1;\n}\nfunction eitherStridesOrDilationsAreOne(strides, dilations) {\n    return tupleValuesAreOne(strides) || tupleValuesAreOne(dilations);\n}\n","map":{"version":3,"file":"conv.js","sourceRoot":"","sources":["../src/ops/conv.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {doc} from '../doc';\nimport {ENV} from '../environment';\nimport {Tensor2D, Tensor3D, Tensor4D} from '../tensor';\nimport * as util from '../util';\nimport * as conv_util from './conv_util';\nimport {operation} from './operation';\n\nexport class ConvOps {\n  /**\n   * Computes a 1D convolution over the input x.\n   *\n   * @param x The input tensor, of rank 3 or rank 2, of shape\n   *     `[batch, width, inChannels]`. If rank 2, batch of 1 is assumed.\n   * @param filter The filter, rank 3, of shape\n   *     `[filterWidth, inDepth, outDepth]`.\n   * @param stride The number of entries by which the filter is moved right at\n   *     each step.\n   * @param pad The type of padding algorithm.\n   *    - `same` and stride 1: output will be of same size as input,\n   *       regardless of filter size.\n   *    - `valid`: output will be smaller than input if filter is larger\n   *       than 1x1.\n   *   - For more info, see this guide:\n   *     [https://www.tensorflow.org/api_guides/python/nn#Convolution](\n   *          https://www.tensorflow.org/api_guides/python/nn#Convolution)\n   * @param dataFormat An optional string from \"NWC\", \"NCW\". Defaults to \"NWC\",\n   *     the data is stored in the order of [batch, in_width, in_channels]. Only\n   *     \"NWC\" is currently supported.\n   * @param dilation The dilation rate in which we sample input values in\n   *     atrous convolution. Defaults to `1`. If it is greater than 1, then\n   *     stride must be `1`.\n   * @param dimRoundingMode The rounding mode used when computing output\n   *     dimensions if pad is a number. If none is provided, it will not round\n   *     and error if the output is of fractional size.\n   */\n  @doc({heading: 'Operations', subheading: 'Convolution'})\n  @operation\n  static conv1d<T extends Tensor2D|Tensor3D>(\n      x: T, filter: Tensor3D, stride: number, pad: 'valid'|'same'|number,\n      dataFormat: 'NWC'|'NCW' = 'NWC', dilation = 1,\n      dimRoundingMode?: 'floor'|'round'|'ceil'): T {\n    util.assertArgumentsAreTensors({x, filter}, 'conv1d');\n\n    let x3D = x as Tensor3D;\n    let reshapedTo3D = false;\n    if (x.rank === 2) {\n      reshapedTo3D = true;\n      x3D = x.as3D(1, x.shape[0], x.shape[1]);\n    }\n\n    util.assert(\n        x3D.rank === 3,\n        `Error in conv1d: input must be rank 3, but got rank ${x3D.rank}.`);\n    util.assert(\n        filter.rank === 3,\n        `Error in conv1d: filter must be rank 3, but got rank ` +\n            `${filter.rank}.`);\n    if (dimRoundingMode != null) {\n      util.assert(\n          util.isInt(pad as number),\n          `Error in conv1d: pad must be an integer when using, ` +\n              `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n    }\n\n    util.assert(\n        x3D.shape[2] === filter.shape[1],\n        `Error in conv1d: depth of input (${x3D.shape[2]}) must match  ` +\n            `input depth for filter ${filter.shape[1]}.`);\n    util.assert(\n        eitherStridesOrDilationsAreOne(stride, dilation),\n        'Error in conv1D: Either stride or dilation must be 1.' +\n            `Got stride ${stride} and dilation '${dilation}'`);\n    util.assert(\n        dataFormat === 'NWC',\n        `Error in conv1d: got dataFormat of ${\n            dataFormat} but only NWC is currently supported.`);\n\n    const filter4D =\n        filter.as4D(1, filter.shape[0], filter.shape[1], filter.shape[2]);\n    const input4D = x3D.as4D(x3D.shape[0], 1, x3D.shape[1], x3D.shape[2]);\n    const strides: [number, number] = [1, stride];\n    const dilations: [number, number] = [1, dilation];\n\n    const conv2dDataFormat = 'NHWC';\n\n    const res = ConvOps.conv2d(\n        input4D, filter4D, strides, pad, conv2dDataFormat, dilations,\n        dimRoundingMode);\n\n    if (reshapedTo3D) {\n      return res.as2D(res.shape[2], res.shape[3]) as T;\n    }\n    return res.as3D(res.shape[0], res.shape[2], res.shape[3]) as T;\n  }\n\n  /**\n   * Computes a 2D convolution over the input x.\n   *\n   * @param x The input tensor, of rank 4 or rank 3, of shape\n   *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is\n   * assumed.\n   * @param filter The filter, rank 4, of shape\n   *     `[filterHeight, filterWidth, inDepth, outDepth]`.\n   * @param strides The strides of the convolution: `[strideHeight,\n   * strideWidth]`.\n   * @param pad The type of padding algorithm.\n   *    - `same` and stride 1: output will be of same size as input,\n   *       regardless of filter size.\n   *    - `valid`: output will be smaller than input if filter is larger\n   *       than 1x1.\n   *   - For more info, see this guide:\n   *     [https://www.tensorflow.org/api_guides/python/nn#Convolution](\n   *          https://www.tensorflow.org/api_guides/python/nn#Convolution)\n   * @param dataFormat: An optional string from: \"NHWC\", \"NCHW\". Defaults to\n   *     \"NHWC\". Specify the data format of the input and output data. With the\n   *     default format \"NHWC\", the data is stored in the order of: [batch,\n   *     height, width, channels]. Only \"NHWC\" is currently supported.\n   * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`\n   *     in which we sample input values across the height and width dimensions\n   *     in atrous convolution. Defaults to `[1, 1]`. If `dilations` is a single\n   *     number, then `dilationHeight == dilationWidth`. If it is greater than\n   *     1, then all values of `strides` must be 1.\n   * @param dimRoundingMode The rounding mode used when computing output\n   *     dimensions if pad is a number. If none is provided, it will not round\n   *     and error if the output is of fractional size.\n   */\n  @doc({heading: 'Operations', subheading: 'Convolution'})\n  @operation\n  static conv2d<T extends Tensor3D|Tensor4D>(\n      x: T, filter: Tensor4D, strides: [number, number]|number,\n      pad: 'valid'|'same'|number, dataFormat: 'NHWC'|'NCHW' = 'NHWC',\n      dilations: [number, number]|number = [1, 1],\n      dimRoundingMode?: 'floor'|'round'|'ceil'): T {\n    util.assertArgumentsAreTensors({x, filter}, 'conv2d');\n\n    let x4D = x as Tensor4D;\n    let reshapedTo4D = false;\n\n    if (x.rank === 3) {\n      reshapedTo4D = true;\n      x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);\n    }\n    util.assert(\n        x4D.rank === 4,\n        `Error in conv2d: input must be rank 4, but got rank ${x4D.rank}.`);\n    util.assert(\n        filter.rank === 4,\n        `Error in conv2d: filter must be rank 4, but got rank ` +\n            `${filter.rank}.`);\n    if (dimRoundingMode != null) {\n      util.assert(\n          util.isInt(pad as number),\n          `Error in conv2d: pad must be an integer when using, ` +\n              `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n    }\n\n    util.assert(\n        x4D.shape[3] === filter.shape[2],\n        `Error in conv2d: depth of input (${x4D.shape[3]}) must match  ` +\n            `input depth for filter ${filter.shape[2]}.`);\n    util.assert(\n        eitherStridesOrDilationsAreOne(strides, dilations),\n        'Error in conv2D: Either strides or dilations must be 1.' +\n            `Got strides ${strides} and dilations '${dilations}'`);\n    util.assert(\n        dataFormat === 'NHWC',\n        `Error in conv2d: got dataFormat of ${\n            dataFormat} but only NHWC is currently supported.`);\n\n    const convInfo = conv_util.computeConv2DInfo(\n        x4D.shape, filter.shape, strides, dilations, pad, dimRoundingMode);\n\n    const grad = (dy: Tensor4D) => {\n      util.assert(\n          tupleValuesAreOne(dilations),\n          'Error in gradient of conv2D: dilation rates greater than 1 are not' +\n              `yet supported in gradients. Got dilations '${dilations}'`);\n\n      return {\n        x: () => ConvOps.conv2dDerInput(x4D.shape, dy, filter, strides, pad),\n        filter: () =>\n            ConvOps.conv2dDerFilter(x4D, dy, filter.shape, strides, pad)\n      };\n    };\n\n    const res = ENV.engine.runKernel(\n        backend => backend.conv2d(x4D, filter, convInfo), {x: x4D, filter},\n        grad);\n    if (reshapedTo4D) {\n      return res.as3D(res.shape[1], res.shape[2], res.shape[3]) as T;\n    }\n    return res as T;\n  }\n\n  /**\n   * Computes the derivative of the input of a 2D convolution.\n   *\n   * @param xShape The shape of the input: [batch, height, width, inDepth].\n   * If length of 3, batch of 1 is assumed.\n   * @param dy The derivative of the output, of rank 4 or rank 3 of shape\n   *   `[batch, outHeight, outWidth, outDepth]`. If rank 3, batch of 1 is\n   * assumed.\n   * @param filter The filter, rank 4, of shape\n   *     `[filterHeight, filterWidth, inDepth, outDepth]`.\n   * @param strides The strides of the convolution: `[strideHeight,\n   * strideWidth]`.\n   * @param pad The type of padding algorithm used:\n   *    - `same` and stride 1: output will be of same size as input,\n   *       regardless of filter size.\n   *    - `valid`: output will be smaller than input if filter is larger\n   *       than 1x1.\n   * @param dimRoundingMode The rounding mode used when computing output\n   *     dimensions if pad is a number. If none is provided, it will not round\n   *     and error if the output is of fractional size.\n   */\n  @operation\n  static conv2dDerInput<T extends Tensor3D|Tensor4D>(\n      xShape: [number, number, number, number]|[number, number, number], dy: T,\n      filter: Tensor4D, strides: [number, number]|number,\n      pad: 'valid'|'same'|number, dimRoundingMode?: 'floor'|'round'|'ceil'): T {\n    util.assertArgumentsAreTensors({dy, filter}, 'conv2dDerInput');\n\n    util.assert(\n        xShape.length === dy.rank,\n        `Length of inShape ` +\n            `(${xShape.length}) and rank of dy (${dy.rank}) must match`);\n\n    let xShape4D = xShape as [number, number, number, number];\n    let dy4D = dy as Tensor4D;\n    let reshapedTo4D = false;\n    if (dy.rank === 3) {\n      reshapedTo4D = true;\n      dy4D = dy.as4D(1, dy.shape[0], dy.shape[1], dy.shape[2]);\n      xShape4D = [1, xShape[0], xShape[1], xShape[2]];\n    }\n\n    const inDepth = xShape4D[3];\n    const outDepth = dy4D.shape[3];\n    util.assert(\n        xShape4D.length === 4,\n        `Error in conv2dDerInput: inShape must be length 4, but got length ` +\n            `${xShape4D.length}.`);\n    util.assert(\n        dy4D.rank === 4,\n        `Error in conv2dDerInput: dy must be rank 4, but got ` +\n            `rank ${dy4D.rank}`);\n    util.assert(\n        filter.rank === 4,\n        `Error in conv2dDerInput: filter must be rank 4, but got ` +\n            `rank ${filter.rank}`);\n    util.assert(\n        inDepth === filter.shape[2],\n        `Error in conv2dDerInput: depth of input (${inDepth}) must ` +\n            `match input depth for filter ${filter.shape[2]}.`);\n    util.assert(\n        outDepth === filter.shape[3],\n        `Error in conv2dDerInput: depth of output (${outDepth}) must` +\n            `match output depth for filter ${filter.shape[3]}.`);\n    if (dimRoundingMode != null) {\n      util.assert(\n          util.isInt(pad as number),\n          `Error in conv2dDerInput: pad must be an integer when using, ` +\n              `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n    }\n\n    const dilations = 1;\n\n    const convInfo = conv_util.computeConv2DInfo(\n        xShape4D, filter.shape, strides, dilations, pad, dimRoundingMode);\n    const res = ENV.engine.runKernel(\n        backend => backend.conv2dDerInput(dy4D, filter, convInfo), {dy4D});\n    if (reshapedTo4D) {\n      return res.as3D(res.shape[1], res.shape[2], res.shape[3]) as T;\n    }\n    return res as T;\n  }\n\n  /**\n   * Computes the derivative of the filter of a 2D convolution.\n   *\n   * @param x The input tensor, of rank 4 or rank 3 of shape\n   *     [batch, height, width, inChannels]. If rank 3, batch of 1 is assumed.\n   * @param dy The dy image, of rank 4 or rank 3, of shape\n   *     [batch, height, width, outDepth]. If rank 3, batch of 1 is assumed.\n   * @param filterShape The shape of the filter, length 4,\n   *     [filterHeight, filterWidth, inDepth, outDepth].\n   * @param strides The strides of the convolution: [strideHeight,\n   * strideWidth].\n   * @param pad A string from: 'same', 'valid'. The type of padding algorithm\n   *     used in the forward prop of the op.\n   * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. The\n   *     rounding mode used when computing output dimensions if pad is a\n   *     number. If none is provided, it will not round and error if the output\n   *     is of fractional size.\n   */\n  @operation\n  static conv2dDerFilter<T extends Tensor3D|Tensor4D>(\n      x: T, dy: T, filterShape: [number, number, number, number],\n      strides: [number, number]|number, pad: 'valid'|'same'|number,\n      dimRoundingMode?: 'floor'|'round'|'ceil'): Tensor4D {\n    util.assertArgumentsAreTensors({x, dy}, 'conv2dDerFilter');\n\n    let x4D = x as Tensor4D;\n    if (x.rank === 3) {\n      x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);\n    }\n    let dy4D = dy as Tensor4D;\n    if (dy4D.rank === 3) {\n      dy4D = dy.as4D(1, dy.shape[0], dy.shape[1], dy.shape[2]);\n    }\n    util.assert(\n        x4D.rank === 4,\n        `Error in conv2dDerFilter: input must be rank 4, but got shape ` +\n            `${x4D.shape}.`);\n    util.assert(\n        dy4D.rank === 4,\n        `Error in conv2dDerFilter: dy must be rank 4, but got shape ` +\n            `${dy4D.shape}.`);\n    util.assert(\n        filterShape.length === 4,\n        `Error in conv2dDerFilter: filterShape must be length 4, but got ` +\n            `${filterShape}.`);\n    util.assert(\n        x4D.shape[3] === filterShape[2],\n        `Error in conv2dDerFilter: depth of input ${x4D.shape[3]}) must ` +\n            `match input depth in filter (${filterShape[2]}.`);\n    util.assert(\n        dy4D.shape[3] === filterShape[3],\n        `Error in conv2dDerFilter: depth of dy (${dy4D.shape[3]}) must ` +\n            `match output depth for filter (${filterShape[3]}).`);\n    if (dimRoundingMode != null) {\n      util.assert(\n          util.isInt(pad as number),\n          `Error in conv2dDerFilter: pad must be an integer when using, ` +\n              `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n    }\n\n    const dilations = 1;\n\n    const convInfo = conv_util.computeConv2DInfo(\n        x4D.shape, filterShape, strides, dilations, pad, dimRoundingMode);\n    return ENV.engine.runKernel(\n        backend => backend.conv2dDerFilter(x4D, dy4D, convInfo), {x4D, dy4D});\n  }\n\n  /**\n   * Computes the transposed 2D convolution of an image, also known as a\n   * deconvolution.\n   *\n   * @param x The input image, of rank 4 or rank 3, of shape\n   *   `[batch, height, width, inDepth]`. If rank 3, batch of 1 is assumed.\n   * @param filter The filter, rank 4, of shape\n   *     `[filterHeight, filterWidth, outDepth, inDepth]`.\n   *     `inDepth` must match `inDepth` in `x`.\n   * @param outputShape Output shape, of rank 4 or rank 3:\n   *     `[batch, height, width, outDepth]`. If rank 3, batch of 1 is assumed.\n   * @param strides The strides of the original convolution:\n   *     `[strideHeight, strideWidth]`.\n   * @param pad  The type of padding algorithm used in the non-transpose version\n   *    of the op.\n   * @param dimRoundingMode The rounding mode used when computing output\n   *    dimensions if pad is a number. If none is provided, it will not round\n   *    and error if the output is of fractional size.\n   */\n  @doc({heading: 'Operations', subheading: 'Convolution'})\n  @operation\n  static conv2dTranspose<T extends Tensor3D|Tensor4D>(\n      x: T, filter: Tensor4D,\n      outputShape: [number, number, number, number]|[number, number, number],\n      strides: [number, number]|number, pad: 'valid'|'same'|number,\n      dimRoundingMode?: 'floor'|'round'|'ceil'): T {\n    util.assertArgumentsAreTensors({x, filter}, 'conv2dTranspose');\n\n    return ConvOps.conv2dDerInput(\n        outputShape, x, filter, strides, pad, dimRoundingMode);\n  }\n\n  /**\n   * Depthwise 2D convolution.\n   *\n   * Given a 4D `input` array and a `filter` array of shape\n   * `[filterHeight, filterWidth, inChannels, channelMultiplier]` containing\n   * `inChannels` convolutional filters of depth 1, this op applies a\n   * different filter to each input channel (expanding from 1 channel to\n   * `channelMultiplier` channels for each), then concatenates the results\n   * together. The output has `inChannels * channelMultiplier` channels.\n   *\n   * See\n   * [https://www.tensorflow.org/api_docs/python/tf/nn/depthwise_conv2d](\n   *     https://www.tensorflow.org/api_docs/python/tf/nn/depthwise_conv2d)\n   * for more details.\n   *\n   * @param x The input tensor, of rank 4 or rank 3, of shape\n   *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is\n   * assumed.\n   * @param filter The filter tensor, rank 4, of shape\n   *     `[filterHeight, filterWidth, inChannels, channelMultiplier]`.\n   * @param strides The strides of the convolution: `[strideHeight,\n   * strideWidth]`. If strides is a single number, then `strideHeight ==\n   * strideWidth`.\n   * @param pad The type of padding algorithm.\n   *   - `same` and stride 1: output will be of same size as input,\n   *       regardless of filter size.\n   *   - `valid`: output will be smaller than input if filter is larger\n   *       than 1x1.\n   *   - For more info, see this guide:\n   *     [https://www.tensorflow.org/api_guides/python/nn#Convolution](\n   *          https://www.tensorflow.org/api_guides/python/nn#Convolution)\n   * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`\n   *     in which we sample input values across the height and width dimensions\n   *     in atrous convolution. Defaults to `[1, 1]`. If `rate` is a single\n   *     number, then `dilationHeight == dilationWidth`. If it is greater than\n   *     1, then all values of `strides` must be 1.\n   * @param dataFormat: An optional string from: \"NHWC\", \"NCHW\". Defaults to\n   *     \"NHWC\". Specify the data format of the input and output data. With the\n   *     default format \"NHWC\", the data is stored in the order of: [batch,\n   *     height, width, channels]. Only \"NHWC\" is currently supported.\n   * @param dimRoundingMode The rounding mode used when computing output\n   *     dimensions if pad is a number. If none is provided, it will not round\n   *     and error if the output is of fractional size.\n   */\n  @doc({heading: 'Operations', subheading: 'Convolution'})\n  @operation\n  static depthwiseConv2d<T extends Tensor3D|Tensor4D>(\n      x: T, filter: Tensor4D, strides: [number, number]|number,\n      pad: 'valid'|'same'|number, dataFormat: 'NHWC'|'NCHW' = 'NHWC',\n      dilations: [number, number]|number = [1, 1],\n      dimRoundingMode?: 'floor'|'round'|'ceil'): T {\n    util.assertArgumentsAreTensors({x, filter}, 'depthwiseConv2d');\n\n    let x4D = x as Tensor4D;\n    let reshapedTo4D = false;\n    if (x.rank === 3) {\n      reshapedTo4D = true;\n      x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);\n    }\n    util.assert(\n        x4D.rank === 4,\n        `Error in depthwiseConv2D: input must be rank 4, but got ` +\n            `rank ${x4D.rank}.`);\n    util.assert(\n        filter.rank === 4,\n        `Error in depthwiseConv2D: filter must be rank 4, but got rank ` +\n            `${filter.rank}.`);\n    util.assert(\n        x4D.shape[3] === filter.shape[2],\n        `Error in depthwiseConv2D: number of input channels ` +\n            `(${x4D.shape[3]}) must match the inChannels dimension in ` +\n            `filter ${filter.shape[2]}.`);\n    if (dilations == null) {\n      dilations = [1, 1];\n    }\n    util.assert(\n        eitherStridesOrDilationsAreOne(strides, dilations),\n        'Error in depthwiseConv2d: Either strides or dilations must be 1.' +\n            `Got strides ${strides} and dilations '${dilations}'`);\n\n    if (dimRoundingMode != null) {\n      util.assert(\n          util.isInt(pad as number),\n          `Error in depthwiseConv2D: pad must be an integer when using, ` +\n              `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n    }\n\n    const convInfo = conv_util.computeConv2DInfo(\n        x4D.shape, filter.shape, strides, dilations, pad, dimRoundingMode,\n        true /* depthwise */);\n    const res = ENV.engine.runKernel(\n        backend => backend.depthwiseConv2D(x4D, filter, convInfo),\n        {x4D, filter});\n    if (reshapedTo4D) {\n      return res.as3D(res.shape[1], res.shape[2], res.shape[3]) as T;\n    }\n    return res as T;\n  }\n\n  /**\n   * 2-D convolution with separable filters.\n   *\n   * Performs a depthwise convolution that acts separately on channels followed\n   * by a pointwise convolution that mixes channels. Note that this is\n   * separability between dimensions [1, 2] and 3, not spatial separability\n   * between dimensions 1 and 2.\n   *\n   * See\n   * [https://www.tensorflow.org/api_docs/python/tf/nn/separable_conv2d](\n   *     https://www.tensorflow.org/api_docs/python/tf/nn/separable_conv2d)\n   * for more details.\n   *\n   * @param x The input tensor, of rank 4 or rank 3, of shape\n   *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is\n   * assumed.\n   * @param depthwiseFilter The depthwise filter tensor, rank 4, of shape\n   *     `[filterHeight, filterWidth, inChannels, channelMultiplier]`. This is\n   *     the filter used in the first step.\n   * @param pointwiseFilter The pointwise filter tensor, rank 4, of shape\n   *     `[1, 1, inChannels * channelMultiplier, outChannels]`. This is\n   *     the filter used in the second step.\n   * @param strides The strides of the convolution: `[strideHeight,\n   * strideWidth]`. If strides is a single number, then `strideHeight ==\n   * strideWidth`.\n   * @param pad The type of padding algorithm.\n   *   - `same` and stride 1: output will be of same size as input,\n   *       regardless of filter size.\n   *   - `valid`: output will be smaller than input if filter is larger\n   *       than 1x1.\n   *   - For more info, see this guide:\n   *     [https://www.tensorflow.org/api_guides/python/nn#Convolution](\n   *          https://www.tensorflow.org/api_guides/python/nn#Convolution)\n   * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`\n   *     in which we sample input values across the height and width dimensions\n   *     in atrous convolution. Defaults to `[1, 1]`. If `rate` is a single\n   *     number, then `dilationHeight == dilationWidth`. If it is greater than\n   *     1, then all values of `strides` must be 1.\n   * @param dataFormat: An optional string from: \"NHWC\", \"NCHW\". Defaults to\n   *     \"NHWC\". Specify the data format of the input and output data. With the\n   *     default format \"NHWC\", the data is stored in the order of: [batch,\n   *     height, width, channels]. Only \"NHWC\" is currently supported.\n   */\n  @doc({heading: 'Operations', subheading: 'Convolution'})\n  @operation\n  static separableConv2d<T extends Tensor3D|Tensor4D>(\n      x: T, depthwiseFilter: Tensor4D, pointwiseFilter: Tensor4D,\n      strides: [number, number]|number, pad: 'valid'|'same',\n      dilation: [number, number]|number = [1, 1],\n      dataFormat: 'NHWC'|'NCHW' = 'NHWC'): T {\n    util.assertArgumentsAreTensors(\n        {x, depthwiseFilter, pointwiseFilter}, 'separableConv2d');\n\n    let x4D = x as Tensor4D;\n    let reshapedTo4D = false;\n    if (x.rank === 3) {\n      reshapedTo4D = true;\n      x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);\n    }\n\n    if (dataFormat === 'NCHW') {\n      throw new Error(\n          'separableConv2d currently does not support dataFormat NCHW; only ' +\n          'NHWC is supported');\n    }\n\n    util.assert(\n        x4D.rank === 4,\n        `Error in separableConv2d: input must be rank 4, but got ` +\n            `rank ${x4D.rank}.`);\n    util.assert(\n        depthwiseFilter.rank === 4,\n        `Error in separableConv2d: depthwise filter must be rank 4, but got ` +\n            `rank ${depthwiseFilter.rank}.`);\n    util.assert(\n        pointwiseFilter.rank === 4,\n        `Error in separableConv2d: pointwise filter must be rank 4, but got ` +\n            `rank ${depthwiseFilter.rank}.`);\n    util.assert(\n        pointwiseFilter.shape[0] === 1,\n        `Error in separableConv2d: the first dimension of pointwise filter ` +\n            ` must be 1, but got ${pointwiseFilter.shape[0]}.`);\n    util.assert(\n        pointwiseFilter.shape[1] === 1,\n        `Error in separableConv2d: the second dimension of pointwise filter ` +\n            ` must be 1, but got ${pointwiseFilter.shape[1]}.`);\n\n    const inChannels = depthwiseFilter.shape[2];\n    const channelMultiplier = depthwiseFilter.shape[3];\n    util.assert(\n        pointwiseFilter.shape[2] === inChannels * channelMultiplier,\n        `Error in separableConv2d: the third dimension of pointwise filter ` +\n            `must be ${inChannels * channelMultiplier}, ` +\n            `but got ${pointwiseFilter.shape[2]}.`);\n\n    const depthwise = ConvOps.depthwiseConv2d(\n        x4D, depthwiseFilter, strides, pad, dataFormat, dilation);\n    const pointwiseStride = 1;\n    const res = ConvOps.conv2d(\n        depthwise, pointwiseFilter, pointwiseStride, 'valid', dataFormat);\n    if (reshapedTo4D) {\n      return res.as3D(res.shape[1], res.shape[2], res.shape[3]) as T;\n    }\n    return res as T;\n  }\n}\n\nfunction parseTupleParam(param: number|[number, number]): [number, number] {\n  return typeof param === 'number' ? [param, param] : param;\n}\n\nfunction tupleValuesAreOne(param: number|[number, number]): boolean {\n  const [dimA, dimB] = parseTupleParam(param);\n  return dimA === 1 && dimB === 1;\n}\n\nfunction eitherStridesOrDilationsAreOne(\n    strides: number|[number, number],\n    dilations: number|[number, number]): boolean {\n  return tupleValuesAreOne(strides) || tupleValuesAreOne(dilations);\n}\n"]}},"hash":"3632ee3c1068ee8441c54d86da65c7b3","cacheData":{"env":{}}}