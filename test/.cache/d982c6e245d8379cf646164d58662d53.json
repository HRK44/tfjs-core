{"dependencies":[{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/float16/tfjs-core/test/package.json","includedInParent":true,"mtime":1528810356568},{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/float16/tfjs-core/test/.babelrc","includedInParent":true,"mtime":1525096773813},{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/float16/tfjs-core/tsconfig.json","includedInParent":true,"mtime":1528810356568}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar EncodeFloatProgram = (function () {\n    function EncodeFloatProgram(outputShape) {\n        this.variableNames = ['A'];\n        this.outputShape = outputShape;\n        this.userCode = \"\\n      const float FLOAT_MAX = 1.70141184e38;\\n      const float FLOAT_MIN = 1.17549435e-38;\\n\\n      lowp vec4 encode_float(highp float v) {\\n        if (isNaN(v)) {\\n          return vec4(255, 255, 255, 255);\\n        }\\n\\n        highp float av = abs(v);\\n\\n        if(av < FLOAT_MIN) {\\n          return vec4(0.0, 0.0, 0.0, 0.0);\\n        } else if(v > FLOAT_MAX) {\\n          return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\\n        } else if(v < -FLOAT_MAX) {\\n          return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\\n        }\\n\\n        highp vec4 c = vec4(0,0,0,0);\\n\\n        highp float e = floor(log2(av));\\n        //highp float m = av * pow(2.0, -e) - 1.0;\\n        highp float m = exp2(log2(av) - e) - 1.0;\\n\\n        highp float log2m = log2(m);\\n        c[2] = floor(128.0 * m);\\n       // c[2] = floor(exp2(7. + log2m));\\n        m -= c[2] / 128.0;\\n        c[1] = floor(32768.0 * m);\\n       // c[1] = floor(exp2(15. + log2m));\\n        m -= c[1] / 32768.0;\\n        c[0] = floor(8388608.0 * m);\\n       // c[0] = floor(exp2(23. + log2m));\\n\\n        highp float ebias = e + 127.0;\\n        c[3] = floor(ebias / 2.0);\\n        ebias -= c[3] * 2.0;\\n        c[2] += floor(ebias) * 128.0;\\n\\n        c[3] += 128.0 * step(0.0, -v);\\n\\n        return c / 255.0;\\n      }\\n\\n      // vec4 encode_float2(float val) {\\n\\n      //   // TODO: correctly handle denormal numbers\\n      //   // http://www.2ality.com/2012/04/number-encoding.html\\n      //   // encode absolute value + sign\\n      //   float a = abs(val);\\n      //   float exp = floor(log2(a));                 // number of powers of 2\\n      //   // multiply to fill 24 bits (implied leading 1)\\n      //   float mant = pow(2.,log2(a)-exp) * pow(2.,23.);\\n      //   float mant1 = floor(mant / 256. / 256.);\\n      // first 8 bits of mantissa\\n      //   float mant2 = mod(floor(mant / 256.),256.); // second 8 bits\\n      //   float mant3 = mod(mant,256.);               // third 8 bits\\n\\n      //   highp float sign = 128.-128.*(a/val);\\t\\t\\t// sign bit is 256 or 0\\n      //   highp float e = (sign+exp+127.)/510.;\\t\\t// exponent and sign\\n      //   // handle leading bit\\n      //   highp float m1 = (mant1-(128.*(1.-mod(exp+127.,2.))))/255.;\\n      //   highp float m2 = (mant2)/255.;\\t\\t\\t\\t// middle part\\n      //   highp float m3 = (mant3+.5)/255.;\\t\\t\\t// scale to 0 - 255\\n\\n      //   return vec4(m3,m2,m1,e);\\n      // }\\n\\n      void main() {\\n        float x = getAAtOutCoords();\\n        gl_FragColor = encode_float(x);\\n      }\\n    \";\n    }\n    return EncodeFloatProgram;\n}());\nexports.EncodeFloatProgram = EncodeFloatProgram;\n","map":{"version":3,"file":"encode_float_gpu.js","sourceRoot":"","sources":["../src/kernels/webgl/encode_float_gpu.ts"],"names":[],"mappings":";;AAmBA;IAKE,4BAAY,WAAqB;QAJjC,kBAAa,GAAG,CAAC,GAAG,CAAC,CAAC;QAKpB,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;QAC/B,IAAI,CAAC,QAAQ,GAAG,+9EAyEf,CAAC;IACJ,CAAC;IACH,yBAAC;AAAD,CAAC,AAlFD,IAkFC;AAlFY,gDAAkB","sourcesContent":["/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class EncodeFloatProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  outputShape: number[];\n\n  constructor(outputShape: number[]) {\n    this.outputShape = outputShape;\n    this.userCode = `\n      const float FLOAT_MAX = 1.70141184e38;\n      const float FLOAT_MIN = 1.17549435e-38;\n\n      lowp vec4 encode_float(highp float v) {\n        if (isNaN(v)) {\n          return vec4(255, 255, 255, 255);\n        }\n\n        highp float av = abs(v);\n\n        if(av < FLOAT_MIN) {\n          return vec4(0.0, 0.0, 0.0, 0.0);\n        } else if(v > FLOAT_MAX) {\n          return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n        } else if(v < -FLOAT_MAX) {\n          return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n        }\n\n        highp vec4 c = vec4(0,0,0,0);\n\n        highp float e = floor(log2(av));\n        //highp float m = av * pow(2.0, -e) - 1.0;\n        highp float m = exp2(log2(av) - e) - 1.0;\n\n        highp float log2m = log2(m);\n        c[2] = floor(128.0 * m);\n       // c[2] = floor(exp2(7. + log2m));\n        m -= c[2] / 128.0;\n        c[1] = floor(32768.0 * m);\n       // c[1] = floor(exp2(15. + log2m));\n        m -= c[1] / 32768.0;\n        c[0] = floor(8388608.0 * m);\n       // c[0] = floor(exp2(23. + log2m));\n\n        highp float ebias = e + 127.0;\n        c[3] = floor(ebias / 2.0);\n        ebias -= c[3] * 2.0;\n        c[2] += floor(ebias) * 128.0;\n\n        c[3] += 128.0 * step(0.0, -v);\n\n        return c / 255.0;\n      }\n\n      // vec4 encode_float2(float val) {\n\n      //   // TODO: correctly handle denormal numbers\n      //   // http://www.2ality.com/2012/04/number-encoding.html\n      //   // encode absolute value + sign\n      //   float a = abs(val);\n      //   float exp = floor(log2(a));                 // number of powers of 2\n      //   // multiply to fill 24 bits (implied leading 1)\n      //   float mant = pow(2.,log2(a)-exp) * pow(2.,23.);\n      //   float mant1 = floor(mant / 256. / 256.);\n      // first 8 bits of mantissa\n      //   float mant2 = mod(floor(mant / 256.),256.); // second 8 bits\n      //   float mant3 = mod(mant,256.);               // third 8 bits\n\n      //   highp float sign = 128.-128.*(a/val);\t\t\t// sign bit is 256 or 0\n      //   highp float e = (sign+exp+127.)/510.;\t\t// exponent and sign\n      //   // handle leading bit\n      //   highp float m1 = (mant1-(128.*(1.-mod(exp+127.,2.))))/255.;\n      //   highp float m2 = (mant2)/255.;\t\t\t\t// middle part\n      //   highp float m3 = (mant3+.5)/255.;\t\t\t// scale to 0 - 255\n\n      //   return vec4(m3,m2,m1,e);\n      // }\n\n      void main() {\n        float x = getAAtOutCoords();\n        gl_FragColor = encode_float(x);\n      }\n    `;\n  }\n}\n"]}},"hash":"65ee6b644f845317c73f3608aef5b1be","cacheData":{"env":{}}}