{"dependencies":[{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/float16/tfjs-core/test/package.json","includedInParent":true,"mtime":1528810356568},{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/float16/tfjs-core/test/.babelrc","includedInParent":true,"mtime":1525096773813},{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/float16/tfjs-core/tsconfig.json","includedInParent":true,"mtime":1528810356568}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SegmentOpProgram = (function () {\n    function SegmentOpProgram(segOpInfo, segOpType) {\n        this.variableNames = ['x', 'segmentIds'];\n        var windowSize = segOpInfo.windowSize;\n        var batchSize = segOpInfo.batchSize;\n        var inSize = segOpInfo.inSize;\n        var numSegments = segOpInfo.numSegments;\n        var outSize = numSegments * Math.ceil(inSize / windowSize);\n        this.outputShape = [batchSize, outSize];\n        var initializationValue = '0.0';\n        var returnValue = \"sumValue\";\n        var windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;\n        var windowSizeVec4Remainder = windowSize % 4;\n        var updateSnippet = \"\\n        sumValue += dot(values, filter);\\n    \";\n        var checkValueOutOfBounds = '';\n        if (inSize % windowSize > 0) {\n            checkValueOutOfBounds = \"\\n        if (inIdx < 0 || inIdx >= \" + inSize + \") {\\n          return initializationValue;\\n        }\\n      \";\n        }\n        var checkSegmentIdOutOfBounds = '';\n        if (inSize % windowSize > 0) {\n            checkSegmentIdOutOfBounds = \"\\n        if (inIdx < 0 || inIdx >= \" + inSize + \") {\\n          return -1.0;\\n        }\\n      \";\n        }\n        this.userCode = \"\\n      const float initializationValue = \" + initializationValue + \";\\n\\n      float getValue(int batch, int inIdx) {\\n        \" + checkValueOutOfBounds + \"\\n        return getX(batch, inIdx);\\n      }\\n\\n      float getSegmentIdAtIndex(int inIdx) {\\n        \" + checkSegmentIdOutOfBounds + \"\\n        return getSegmentIds(inIdx);\\n      }\\n\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int outIdx = coords[1];\\n        int inOffset = int(floor(float(outIdx) / float(\\n          \" + numSegments + \")) * float(\" + windowSize + \"));\\n        int currentSeg = int(mod(float(outIdx), float(\" + numSegments + \")));\\n\\n        float sumValue = 0.0;\\n\\n        for (int i = 0; i < \" + windowSizeNearestVec4 + \"; i += 4) {\\n          int inIdx = inOffset + i;\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            getValue(batch, inIdx + 2),\\n            getValue(batch, inIdx + 3)\\n          );\\n\\n          vec4 filter = vec4(\\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\\n          );\\n\\n          \" + updateSnippet + \"\\n        }\\n\\n        int inIdx = inOffset + \" + windowSizeNearestVec4 + \";\\n        if (\" + (windowSizeVec4Remainder === 1) + \") {\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            initializationValue,\\n            initializationValue,\\n            initializationValue\\n          );\\n\\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\\n\\n          vec4 filter = vec4(\\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\\n            0,\\n            0,\\n            0\\n          );\\n\\n          \" + updateSnippet + \"\\n        } else if (\" + (windowSizeVec4Remainder === 2) + \") {\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            initializationValue,\\n            initializationValue\\n          );\\n\\n          vec4 filter = vec4(\\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\\n              0,\\n              0\\n          );\\n\\n          \" + updateSnippet + \"\\n        } else if (\" + (windowSizeVec4Remainder === 3) + \") {\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            getValue(batch, inIdx + 2),\\n            initializationValue\\n          );\\n\\n          vec4 filter = vec4(\\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\\n            0\\n          );\\n\\n          \" + updateSnippet + \"\\n        }\\n        setOutput(\" + returnValue + \");\\n      }\\n    \";\n    }\n    return SegmentOpProgram;\n}());\nexports.SegmentOpProgram = SegmentOpProgram;\n","map":{"version":3,"file":"segment_gpu.js","sourceRoot":"","sources":["../src/kernels/webgl/segment_gpu.ts"],"names":[],"mappings":";;AAoBA;IAKE,0BAAY,SAAoB,EAAE,SAA+B;QAJjE,kBAAa,GAAG,CAAC,GAAG,EAAE,YAAY,CAAC,CAAC;QAKlC,IAAM,UAAU,GAAG,SAAS,CAAC,UAAU,CAAC;QACxC,IAAM,SAAS,GAAG,SAAS,CAAC,SAAS,CAAC;QACtC,IAAM,MAAM,GAAG,SAAS,CAAC,MAAM,CAAC;QAChC,IAAM,WAAW,GAAG,SAAS,CAAC,WAAW,CAAC;QAC1C,IAAM,OAAO,GAAG,WAAW,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,UAAU,CAAC,CAAC;QAC7D,IAAI,CAAC,WAAW,GAAG,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;QAExC,IAAM,mBAAmB,GAAG,KAAK,CAAC;QAClC,IAAM,WAAW,GAAG,UAAU,CAAC;QAE/B,IAAM,qBAAqB,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;QAC7D,IAAM,uBAAuB,GAAG,UAAU,GAAG,CAAC,CAAC;QAE/C,IAAM,aAAa,GAAG,kDAErB,CAAC;QAEF,IAAI,qBAAqB,GAAG,EAAE,CAAC;QAC/B,EAAE,CAAC,CAAC,MAAM,GAAG,UAAU,GAAG,CAAC,CAAC,CAAC,CAAC;YAC5B,qBAAqB,GAAG,yCACM,MAAM,kEAGnC,CAAC;QACJ,CAAC;QAED,IAAI,yBAAyB,GAAG,EAAE,CAAC;QACnC,EAAE,CAAC,CAAC,MAAM,GAAG,UAAU,GAAG,CAAC,CAAC,CAAC,CAAC;YAC5B,yBAAyB,GAAG,yCACE,MAAM,mDAGnC,CAAC;QACJ,CAAC;QAED,IAAI,CAAC,QAAQ,GAAG,+CACsB,mBAAmB,mEAGnD,qBAAqB,+GAKrB,yBAAyB,+PASvB,WAAW,mBAAc,UAAU,mEACS,WAAW,6EAIrC,qBAAqB,4lBAgBvC,aAAa,sDAGQ,qBAAqB,wBACxC,uBAAuB,KAAK,CAAC,gbAiB/B,aAAa,8BACJ,uBAAuB,KAAK,CAAC,sbAetC,aAAa,8BACJ,uBAAuB,KAAK,CAAC,ifAetC,aAAa,uCAEL,WAAW,sBAE1B,CAAC;IACJ,CAAC;IACH,uBAAC;AAAD,CAAC,AA3ID,IA2IC;AA3IY,4CAAgB","sourcesContent":["/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {SegOpInfo} from '../../ops/segment_util';\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class SegmentOpProgram implements GPGPUProgram {\n  variableNames = ['x', 'segmentIds'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(segOpInfo: SegOpInfo, segOpType: 'unsortedSegmentSum') {\n    const windowSize = segOpInfo.windowSize;\n    const batchSize = segOpInfo.batchSize;\n    const inSize = segOpInfo.inSize;\n    const numSegments = segOpInfo.numSegments;\n    const outSize = numSegments * Math.ceil(inSize / windowSize);\n    this.outputShape = [batchSize, outSize];\n\n    const initializationValue = '0.0';\n    const returnValue = `sumValue`;\n\n    const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;\n    const windowSizeVec4Remainder = windowSize % 4;\n\n    const updateSnippet = `\n        sumValue += dot(values, filter);\n    `;\n\n    let checkValueOutOfBounds = '';\n    if (inSize % windowSize > 0) {\n      checkValueOutOfBounds = `\n        if (inIdx < 0 || inIdx >= ${inSize}) {\n          return initializationValue;\n        }\n      `;\n    }\n\n    let checkSegmentIdOutOfBounds = '';\n    if (inSize % windowSize > 0) {\n      checkSegmentIdOutOfBounds = `\n        if (inIdx < 0 || inIdx >= ${inSize}) {\n          return -1.0;\n        }\n      `;\n    }\n\n    this.userCode = `\n      const float initializationValue = ${initializationValue};\n\n      float getValue(int batch, int inIdx) {\n        ${checkValueOutOfBounds}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${checkSegmentIdOutOfBounds}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${numSegments})) * float(${windowSize}));\n        int currentSeg = int(mod(float(outIdx), float(${numSegments})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 filter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${updateSnippet}\n        }\n\n        int inIdx = inOffset + ${windowSizeNearestVec4};\n        if (${windowSizeVec4Remainder === 1}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 filter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 2}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 filter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 3}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 filter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${updateSnippet}\n        }\n        setOutput(${returnValue});\n      }\n    `;\n  }\n}\n"]}},"hash":"77f63e503bde45c80a764caddc0ddf8d","cacheData":{"env":{}}}