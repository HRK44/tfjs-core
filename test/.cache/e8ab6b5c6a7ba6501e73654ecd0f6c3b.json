{"dependencies":[{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/float16/tfjs-core/test/package.json","includedInParent":true,"mtime":1525096773813},{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/float16/tfjs-core/test/.babelrc","includedInParent":true,"mtime":1525096773813},{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/float16/tfjs-core/tsconfig.json","includedInParent":true,"mtime":1524062920943},{"name":"../doc","loc":{"line":9,"column":20}},{"name":"../util","loc":{"line":10,"column":19}},{"name":"./operation","loc":{"line":11,"column":26}}],"generated":{"js":"\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar doc_1 = require(\"../doc\");\nvar util = require(\"../util\");\nvar operation_1 = require(\"./operation\");\nvar LSTMOps = (function () {\n    function LSTMOps() {\n    }\n    LSTMOps.multiRNNCell = function (lstmCells, data, c, h) {\n        util.assertArgumentsAreTensors({ data: data, c: c, h: h }, 'multiRNNCell');\n        var input = data;\n        var newStates = [];\n        for (var i = 0; i < lstmCells.length; i++) {\n            var output = lstmCells[i](input, c[i], h[i]);\n            newStates.push(output[0]);\n            newStates.push(output[1]);\n            input = output[1];\n        }\n        var newC = [];\n        var newH = [];\n        for (var i = 0; i < newStates.length; i += 2) {\n            newC.push(newStates[i]);\n            newH.push(newStates[i + 1]);\n        }\n        return [newC, newH];\n    };\n    LSTMOps.basicLSTMCell = function (forgetBias, lstmKernel, lstmBias, data, c, h) {\n        util.assertArgumentsAreTensors({ forgetBias: forgetBias, lstmKernel: lstmKernel, lstmBias: lstmBias, data: data, c: c, h: h }, 'basicLSTMCell');\n        var combined = data.concat(h, 1);\n        var weighted = combined.matMul(lstmKernel);\n        var res = weighted.add(lstmBias);\n        var batchSize = res.shape[0];\n        var sliceCols = res.shape[1] / 4;\n        var sliceSize = [batchSize, sliceCols];\n        var i = res.slice([0, 0], sliceSize);\n        var j = res.slice([0, sliceCols], sliceSize);\n        var f = res.slice([0, sliceCols * 2], sliceSize);\n        var o = res.slice([0, sliceCols * 3], sliceSize);\n        var newC = i.sigmoid().mulStrict(j.tanh()).addStrict(c.mulStrict(forgetBias.add(f).sigmoid()));\n        var newH = newC.tanh().mulStrict(o.sigmoid());\n        return [newC, newH];\n    };\n    __decorate([\n        doc_1.doc({ heading: 'Operations', subheading: 'RNN' }),\n        operation_1.operation\n    ], LSTMOps, \"multiRNNCell\", null);\n    __decorate([\n        doc_1.doc({ heading: 'Operations', subheading: 'RNN' }),\n        operation_1.operation\n    ], LSTMOps, \"basicLSTMCell\", null);\n    return LSTMOps;\n}());\nexports.LSTMOps = LSTMOps;\n","map":{"version":3,"file":"lstm.js","sourceRoot":"","sources":["../src/ops/lstm.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {doc} from '../doc';\nimport {Scalar, Tensor1D, Tensor2D} from '../tensor';\nimport * as util from '../util';\n\nimport {operation} from './operation';\n\n/**\n * @docalias (data: Tensor2D, c: Tensor2D, h: Tensor2D): [Tensor2D, Tensor2D]\n */\nexport type LSTMCellFunc = {\n  (data: Tensor2D, c: Tensor2D, h: Tensor2D): [Tensor2D, Tensor2D];\n};\n\nexport class LSTMOps {\n  /**\n   * Computes the next states and outputs of a stack of LSTMCells.\n   *\n   * Each cell output is used as input to the next cell.\n   *\n   * Returns `[cellState, cellOutput]`.\n   *\n   * Derived from tf.contrib.rn.MultiRNNCell.\n   *\n   * @param lstmCells Array of LSTMCell functions.\n   * @param data The input to the cell.\n   * @param c Array of previous cell states.\n   * @param h Array of previous cell outputs.\n   */\n  @doc({heading: 'Operations', subheading: 'RNN'})\n  @operation\n  static multiRNNCell(\n      lstmCells: LSTMCellFunc[], data: Tensor2D, c: Tensor2D[], h: Tensor2D[]):\n      [Tensor2D[], Tensor2D[]] {\n    util.assertArgumentsAreTensors({data, c, h}, 'multiRNNCell');\n\n    let input = data;\n    const newStates = [];\n    for (let i = 0; i < lstmCells.length; i++) {\n      const output = lstmCells[i](input, c[i], h[i]);\n      newStates.push(output[0]);\n      newStates.push(output[1]);\n      input = output[1];\n    }\n    const newC: Tensor2D[] = [];\n    const newH: Tensor2D[] = [];\n    for (let i = 0; i < newStates.length; i += 2) {\n      newC.push(newStates[i]);\n      newH.push(newStates[i + 1]);\n    }\n    return [newC, newH];\n  }\n\n  /**\n   * Computes the next state and output of a BasicLSTMCell.\n   *\n   * Returns `[newC, newH]`.\n   *\n   * Derived from tf.contrib.rnn.BasicLSTMCell.\n   *\n   * @param forgetBias Forget bias for the cell.\n   * @param lstmKernel The weights for the cell.\n   * @param lstmBias The bias for the cell.\n   * @param data The input to the cell.\n   * @param c Previous cell state.\n   * @param h Previous cell output.\n   */\n  @doc({heading: 'Operations', subheading: 'RNN'})\n  @operation\n  static basicLSTMCell(\n      forgetBias: Scalar, lstmKernel: Tensor2D, lstmBias: Tensor1D,\n      data: Tensor2D, c: Tensor2D, h: Tensor2D): [Tensor2D, Tensor2D] {\n    util.assertArgumentsAreTensors(\n        {forgetBias, lstmKernel, lstmBias, data, c, h}, 'basicLSTMCell');\n\n    const combined = data.concat(h, 1);\n    const weighted = combined.matMul(lstmKernel);\n    const res = weighted.add(lstmBias) as Tensor2D;\n\n    // i = input_gate, j = new_input, f = forget_gate, o = output_gate\n    const batchSize = res.shape[0];\n    const sliceCols = res.shape[1] / 4;\n    const sliceSize: [number, number] = [batchSize, sliceCols];\n    const i = res.slice([0, 0], sliceSize);\n    const j = res.slice([0, sliceCols], sliceSize);\n    const f = res.slice([0, sliceCols * 2], sliceSize);\n    const o = res.slice([0, sliceCols * 3], sliceSize);\n\n    const newC = i.sigmoid().mulStrict(j.tanh()).addStrict(\n        c.mulStrict(forgetBias.add(f).sigmoid() as Tensor2D));\n    const newH = newC.tanh().mulStrict(o.sigmoid());\n    return [newC, newH];\n  }\n}\n"]}},"hash":"90bcbf7ffd2f79baf84e77ca39f80e2d","cacheData":{"env":{}}}