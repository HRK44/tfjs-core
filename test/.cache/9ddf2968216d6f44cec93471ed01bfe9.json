{"dependencies":[{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/float16/tfjs-core/test/package.json","includedInParent":true,"mtime":1528810356568},{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/float16/tfjs-core/test/.babelrc","includedInParent":true,"mtime":1525096773813},{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/float16/tfjs-core/tsconfig.json","includedInParent":true,"mtime":1528810356568},{"name":"../util","loc":{"line":3,"column":21}},{"name":"./reduce_util","loc":{"line":4,"column":28}}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"../util\");\nvar reduce_util_1 = require(\"./reduce_util\");\nfunction segOpComputeOptimalWindowSize(inSize, numSegments) {\n    var done = false;\n    var res;\n    if (inSize <= reduce_util_1.PARALLELIZE_THRESHOLD) {\n        res = inSize;\n        done = true;\n    }\n    else {\n        res = util_1.nearestDivisor(inSize, Math.floor(Math.sqrt(inSize)));\n    }\n    while (!done) {\n        if (res > numSegments || res === inSize) {\n            done = true;\n            break;\n        }\n        else {\n            res = util_1.nearestDivisor(inSize, res + 1);\n        }\n    }\n    return res;\n}\nexports.segOpComputeOptimalWindowSize = segOpComputeOptimalWindowSize;\nfunction computeOutShape(aShape, axis, numSegments) {\n    var outShape = [];\n    var rank = aShape.length;\n    for (var dim = 0; dim < rank; dim++) {\n        if (dim !== axis) {\n            outShape.push(aShape[dim]);\n        }\n        else {\n            outShape.push(numSegments);\n        }\n    }\n    return outShape;\n}\nexports.computeOutShape = computeOutShape;\n","map":{"version":3,"file":"segment_util.js","sourceRoot":"","sources":["../src/ops/segment_util.ts"],"names":[],"mappings":";;AAiBA,gCAAuC;AACvC,6CAAoD;AASpD,uCACI,MAAc,EAAE,WAAmB;IACrC,IAAI,IAAI,GAAG,KAAK,CAAC;IACjB,IAAI,GAAG,CAAC;IAER,EAAE,CAAC,CAAC,MAAM,IAAI,mCAAqB,CAAC,CAAC,CAAC;QACpC,GAAG,GAAG,MAAM,CAAC;QACb,IAAI,GAAG,IAAI,CAAC;IACd,CAAC;IAAC,IAAI,CAAC,CAAC;QACN,GAAG,GAAG,qBAAc,CAAC,MAAM,EAAE,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;IAC9D,CAAC;IAED,OAAO,CAAC,IAAI,EAAE,CAAC;QACb,EAAE,CAAC,CAAC,GAAG,GAAG,WAAW,IAAI,GAAG,KAAK,MAAM,CAAC,CAAC,CAAC;YACxC,IAAI,GAAG,IAAI,CAAC;YACZ,KAAK,CAAC;QACR,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,GAAG,GAAG,qBAAc,CAAC,MAAM,EAAE,GAAG,GAAG,CAAC,CAAC,CAAC;QACxC,CAAC;IACH,CAAC;IACD,MAAM,CAAC,GAAG,CAAC;AACb,CAAC;AArBD,sEAqBC;AAED,yBACI,MAAgB,EAAE,IAAY,EAAE,WAAmB;IACrD,IAAM,QAAQ,GAAG,EAAE,CAAC;IACpB,IAAM,IAAI,GAAG,MAAM,CAAC,MAAM,CAAC;IAC3B,GAAG,CAAC,CAAC,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,IAAI,EAAE,GAAG,EAAE,EAAE,CAAC;QACpC,EAAE,CAAC,CAAC,GAAG,KAAK,IAAI,CAAC,CAAC,CAAC;YACjB,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC;QAC7B,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,QAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QAC7B,CAAC;IACH,CAAC;IACD,MAAM,CAAC,QAAQ,CAAC;AAClB,CAAC;AAZD,0CAYC","sourcesContent":["/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {nearestDivisor} from '../util';\nimport {PARALLELIZE_THRESHOLD} from './reduce_util';\n\nexport interface SegOpInfo {\n  windowSize: number;\n  batchSize: number;\n  inSize: number;\n  numSegments: number;\n}\n\nexport function segOpComputeOptimalWindowSize(\n    inSize: number, numSegments: number): number {\n  let done = false;\n  let res;\n\n  if (inSize <= PARALLELIZE_THRESHOLD) {\n    res = inSize;\n    done = true;\n  } else {\n    res = nearestDivisor(inSize, Math.floor(Math.sqrt(inSize)));\n  }\n\n  while (!done) {\n    if (res > numSegments || res === inSize) {\n      done = true;\n      break;\n    } else {\n      res = nearestDivisor(inSize, res + 1);\n    }\n  }\n  return res;\n}\n\nexport function computeOutShape(\n    aShape: number[], axis: number, numSegments: number): number[] {\n  const outShape = [];\n  const rank = aShape.length;\n  for (let dim = 0; dim < rank; dim++) {\n    if (dim !== axis) {\n      outShape.push(aShape[dim]);\n    } else {\n      outShape.push(numSegments);\n    }\n  }\n  return outShape;\n}\n"]}},"hash":"8d380fac272ddd701da879d2efc47147","cacheData":{"env":{}}}