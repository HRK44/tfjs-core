{"dependencies":[{"name":"/Users/nsthorat/Code/deeplearnjs-clients/float16/tfjs-core/test/package.json","includedInParent":true,"mtime":1528755312004},{"name":"/Users/nsthorat/Code/deeplearnjs-clients/float16/tfjs-core/test/.babelrc","includedInParent":true,"mtime":1524411533119},{"name":"/Users/nsthorat/Code/deeplearnjs-clients/float16/tfjs-core/tsconfig.json","includedInParent":true,"mtime":1528754597009},{"name":"../..","loc":{"line":3,"column":18}},{"name":"../../ops/erf_util","loc":{"line":4,"column":23}},{"name":"../../ops/selu_util","loc":{"line":5,"column":24}}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar __1 = require(\"../..\");\nvar erf_util = require(\"../../ops/erf_util\");\nvar selu_util = require(\"../../ops/selu_util\");\nvar UnaryOpProgram = (function () {\n    function UnaryOpProgram(aShape, opSnippet) {\n        this.variableNames = ['A'];\n        this.outputShape = aShape;\n        this.userCode = \"\\n      float unaryOperation(float x) {\\n        \" + opSnippet() + \"\\n      }\\n\\n      void main() {\\n        float x = getAAtOutCoords();\\n        float y = unaryOperation(x);\\n\\n        setOutput(y);\\n      }\\n    \";\n    }\n    return UnaryOpProgram;\n}());\nexports.UnaryOpProgram = UnaryOpProgram;\nvar CHECK_NAN_SNIPPET = \"if (isNaN(x)) return x;\";\nfunction makeSnippet(snippet, checkNaN) {\n    if (checkNaN === void 0) { checkNaN = function () { return false; }; }\n    return function () { return (checkNaN() ? CHECK_NAN_SNIPPET + '\\n' : '') + snippet; };\n}\nexports.PASS_THROUGH = makeSnippet(\"return x;\");\nexports.ABS = makeSnippet(\"return abs(x);\");\nexports.RELU = makeSnippet(\"return (x < 0.0) ? 0.0 : x;\", function () { return true; });\nexports.ELU = makeSnippet(\"return (x >= 0.0) ? x : (exp(x) - 1.0);\");\nexports.SELU = makeSnippet(\"\\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\\n  // see: https://arxiv.org/abs/1706.02515\\n  float scaleAlpha = \" + selu_util.SELU_SCALEALPHA + \";\\n  float scale = \" + selu_util.SELU_SCALE + \";\\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\\n\");\nfunction STEP(alpha) {\n    if (alpha === void 0) { alpha = 0.0; }\n    return makeSnippet(\"return x > 0.0 ? 1.0 : float(\" + alpha + \");\", function () { return true; });\n}\nexports.STEP = STEP;\nexports.NEG = makeSnippet(\"return -x;\");\nexports.CEIL = makeSnippet(\"return ceil(x);\");\nexports.FLOOR = makeSnippet(\"return floor(x);\");\nexports.SIGN = makeSnippet(\"\\n  if (isNaN(x)) { return 0.0; }\\n  return sign(x);\\n\");\nexports.ROUND = makeSnippet(\"\\n  // OpenGL ES does not support round function.\\n  // The algorithm is based on banker's rounding.\\n  float base = floor(x);\\n  if ((x - base) < 0.5) {\\n    return floor(x);\\n  } else if ((x - base) > 0.5) {\\n    return ceil(x);\\n  } else {\\n    if (mod(base, 2.0) == 0.0) {\\n      return base;\\n    } else {\\n      return base + 1.0;\\n    }\\n  }\\n\");\nexports.EXP = makeSnippet(\"return exp(x);\");\nexports.EXPM1 = makeSnippet(\"return exp(x) - 1.0;\");\nexports.LOG = makeSnippet(\"return log(x);\");\nexports.LOG1P = makeSnippet(\"return log(1.0 + x);\");\nexports.SQRT = makeSnippet(\"return sqrt(x);\");\nexports.RSQRT = makeSnippet(\"return inversesqrt(x);\");\nexports.SIGMOID = makeSnippet(\"return 1.0 / (1.0 + exp(-1.0 * x));\");\nexports.SOFTPLUS = makeSnippet(\"\\n  float epsilon = 1.1920928955078125e-7;\\n  float threshold = log(epsilon) + 2.0;\\n\\n  bool too_large = x > -threshold;\\n  bool too_small = x < threshold;\\n\\n  float result;\\n  float exp_x = exp(x);\\n\\n  if (too_large){\\n    result = x;\\n  }\\n  else if (too_small){\\n    result = exp_x;\\n  }\\n  else{\\n    result = log(exp_x + 1.0);\\n  }\\n  return result;\\n\");\nexports.SIN = makeSnippet(\"return sin(x);\", function () { return true; });\nexports.COS = makeSnippet(\"return cos(x);\", function () { return true; });\nexports.TAN = makeSnippet(\"return tan(x);\");\nexports.ASIN = makeSnippet(\"return asin(x);\");\nexports.ACOS = makeSnippet(\"return acos(x);\");\nexports.ATAN = makeSnippet(\"return atan(x);\", function () { return true; });\nexports.SINH = makeSnippet(\"float e2x = exp(x);\\nreturn (e2x - 1.0 / e2x) / 2.0;\\n\");\nexports.COSH = makeSnippet(\"float e2x = exp(-x);\\nreturn (e2x + 1.0 / e2x) / 2.0;\\n\");\nexports.TANH = makeSnippet(\"float e2x = exp(-2.0 * abs(x));\\nreturn sign(x) * (1.0 - e2x) / (1.0 + e2x);\\n\");\nexports.ASINH = makeSnippet(\"return log(x + sqrt(x * x + 1.0));\");\nexports.ACOSH = makeSnippet(\"return log(x + sqrt(x * x - 1.0));\");\nexports.ATANH = makeSnippet(\"return (log(1.0 + x) - log(1.0 - x)) / 2.0;\", function () { return !__1.ENV.get('WEBGL_RENDER_FLOAT32_ENABLED'); });\nexports.ERF = makeSnippet(\"\\n    // Error function is calculated approximately with elementary function.\\n    // See \\\"Handbook of Mathematical Functions with Formulas,\\n    // Graphs, and Mathematical Tables\\\", Abramowitz and Stegun.\\n    float p = \" + erf_util.ERF_P + \";\\nfloat a1 = \" + erf_util.ERF_A1 + \";\\nfloat a2 = \" + erf_util.ERF_A2 + \";\\nfloat a3 = \" + erf_util.ERF_A3 + \";\\nfloat a4 = \" + erf_util.ERF_A4 + \";\\nfloat a5 = \" + erf_util.ERF_A5 + \";\\n\\nfloat t = 1.0 / (1.0 + p * x);\\nreturn 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-x * x);\\n\");\nexports.SQUARE = makeSnippet(\"return x * x;\");\nexports.RECIPROCAL = makeSnippet(\"return 1.0 / x;\");\nexports.LOGICAL_NOT = makeSnippet(\"return float(!(x >= 1.0));\");\nexports.TO_INT = makeSnippet(\"return float(int(x));\");\n","map":{"version":3,"file":"unaryop_gpu.js","sourceRoot":"","sources":["../src/kernels/webgl/unaryop_gpu.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENV} from '../..';\nimport * as erf_util from '../../ops/erf_util';\nimport * as selu_util from '../../ops/selu_util';\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class UnaryOpProgram implements GPGPUProgram {\n  variableNames = ['A'];\n  userCode: string;\n  outputShape: number[];\n\n  constructor(aShape: number[], opSnippet: () => string) {\n    this.outputShape = aShape;\n    this.userCode = `\n      float unaryOperation(float x) {\n        ${opSnippet()}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `;\n  }\n}\n\nconst CHECK_NAN_SNIPPET = `if (isNaN(x)) return x;`;\n\nfunction makeSnippet(snippet: string, checkNaN = () => false): () => string {\n  return () => (checkNaN() ? CHECK_NAN_SNIPPET + '\\n' : '') + snippet;\n}\n\nexport const PASS_THROUGH = makeSnippet(`return x;`);\n\nexport const ABS = makeSnippet(`return abs(x);`);\n\nexport const RELU = makeSnippet(`return (x < 0.0) ? 0.0 : x;`, () => true);\n\nexport const ELU = makeSnippet(`return (x >= 0.0) ? x : (exp(x) - 1.0);`);\n\nexport const SELU = makeSnippet(`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${selu_util.SELU_SCALEALPHA};\n  float scale = ${selu_util.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`);\n\nexport function STEP(alpha = 0.0) {\n  return makeSnippet(`return x > 0.0 ? 1.0 : float(${alpha});`, () => true);\n}\n\nexport const NEG = makeSnippet(`return -x;`);\n\nexport const CEIL = makeSnippet(`return ceil(x);`);\n\nexport const FLOOR = makeSnippet(`return floor(x);`);\n\nexport const SIGN = makeSnippet(`\n  if (isNaN(x)) { return 0.0; }\n  return sign(x);\n`);\n\nexport const ROUND = makeSnippet(`\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n`);\n\nexport const EXP = makeSnippet(`return exp(x);`);\n\nexport const EXPM1 = makeSnippet(`return exp(x) - 1.0;`);\n\nexport const LOG = makeSnippet(`return log(x);`);\n\nexport const LOG1P = makeSnippet(`return log(1.0 + x);`);\n\nexport const SQRT = makeSnippet(`return sqrt(x);`);\n\nexport const RSQRT = makeSnippet(`return inversesqrt(x);`);\n\nexport const SIGMOID = makeSnippet(`return 1.0 / (1.0 + exp(-1.0 * x));`);\n\n/**\n * mirrors the implementation of tf.nn.softplus: https://goo.gl/vkcvwX\n *\n * epsilon is the difference between 1.0 and the next representable\n * float. For a single precision 32 bit float this should be 2^-23, see:\n * https://math.byu.edu/~schow/work/IEEEFloatingPoint.htm\n *\n * too_large = (x > -threshold) is value above which exp(x) may overflow\n * but softplus(x) == x is within machine epsilon\n *\n * too_small = (x < threshold) is value below which exp(x) may underflow,\n * but softplus(x) == exp(x) is within machine epsilon.\n */\nexport const SOFTPLUS = makeSnippet(`\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n`);\n\nexport const SIN = makeSnippet(`return sin(x);`, () => true);\n\nexport const COS = makeSnippet(`return cos(x);`, () => true);\n\nexport const TAN = makeSnippet(`return tan(x);`);\n\nexport const ASIN = makeSnippet(`return asin(x);`);\n\nexport const ACOS = makeSnippet(`return acos(x);`);\n\nexport const ATAN = makeSnippet(`return atan(x);`, () => true);\n\nexport const SINH = makeSnippet(`float e2x = exp(x);\nreturn (e2x - 1.0 / e2x) / 2.0;\n`);\n\nexport const COSH = makeSnippet(`float e2x = exp(-x);\nreturn (e2x + 1.0 / e2x) / 2.0;\n`);\n\nexport const TANH = makeSnippet(`float e2x = exp(-2.0 * abs(x));\nreturn sign(x) * (1.0 - e2x) / (1.0 + e2x);\n`);\n\nexport const ASINH = makeSnippet(`return log(x + sqrt(x * x + 1.0));`);\n\nexport const ACOSH = makeSnippet(`return log(x + sqrt(x * x - 1.0));`);\n\nexport const ATANH = makeSnippet(\n    `return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,\n    () => !ENV.get('WEBGL_RENDER_FLOAT32_ENABLED'));\n\nexport const ERF = makeSnippet(`\n    // Error function is calculated approximately with elementary function.\n    // See \"Handbook of Mathematical Functions with Formulas,\n    // Graphs, and Mathematical Tables\", Abramowitz and Stegun.\n    float p = ${erf_util.ERF_P};\nfloat a1 = ${erf_util.ERF_A1};\nfloat a2 = ${erf_util.ERF_A2};\nfloat a3 = ${erf_util.ERF_A3};\nfloat a4 = ${erf_util.ERF_A4};\nfloat a5 = ${erf_util.ERF_A5};\n\nfloat t = 1.0 / (1.0 + p * x);\nreturn 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-x * x);\n`);\n\nexport const SQUARE = makeSnippet(`return x * x;`);\n\nexport const RECIPROCAL = makeSnippet(`return 1.0 / x;`);\n\nexport const LOGICAL_NOT = makeSnippet(`return float(!(x >= 1.0));`);\n\nexport const TO_INT = makeSnippet(`return float(int(x));`);\n"]}},"hash":"3ee4fb34ddda65eb7710c8165fe4788f","cacheData":{"env":{}}}