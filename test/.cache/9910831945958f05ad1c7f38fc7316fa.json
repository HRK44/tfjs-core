{"dependencies":[{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/float16/tfjs-core/test/package.json","includedInParent":true,"mtime":1525096773813},{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/float16/tfjs-core/test/.babelrc","includedInParent":true,"mtime":1525096773813},{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/float16/tfjs-core/tsconfig.json","includedInParent":true,"mtime":1524062920943},{"name":"../doc","loc":{"line":9,"column":20}},{"name":"../environment","loc":{"line":10,"column":28}},{"name":"../types","loc":{"line":11,"column":20}},{"name":"../util","loc":{"line":12,"column":19}},{"name":"./broadcast_util","loc":{"line":13,"column":29}},{"name":"./operation","loc":{"line":14,"column":26}}],"generated":{"js":"\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar doc_1 = require(\"../doc\");\nvar environment_1 = require(\"../environment\");\nvar types = require(\"../types\");\nvar util = require(\"../util\");\nvar broadcast_util = require(\"./broadcast_util\");\nvar operation_1 = require(\"./operation\");\nvar LogicalOps = (function () {\n    function LogicalOps() {\n    }\n    LogicalOps.logicalNot = function (x) {\n        util.assertArgumentsAreTensors({ x: x }, 'logicalNot');\n        util.assert(x.dtype === 'bool', 'Error Array must be of type bool.');\n        return environment_1.ENV.engine.runKernel(function (backend) { return backend.logicalNot(x); }, { x: x });\n    };\n    LogicalOps.logicalAnd = function (a, b) {\n        util.assertArgumentsAreTensors({ a: a, b: b }, 'logicalAnd');\n        util.assert(a.dtype === 'bool' && b.dtype === 'bool', 'Error Array must be of type bool.');\n        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);\n        return environment_1.ENV.engine.runKernel(function (backend) { return backend.logicalAnd(a, b); }, { a: a, b: b });\n    };\n    LogicalOps.logicalOr = function (a, b) {\n        util.assertArgumentsAreTensors({ a: a, b: b }, 'logicalOr');\n        util.assert(a.dtype === 'bool' && b.dtype === 'bool', 'Error Array must be of type bool.');\n        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);\n        return environment_1.ENV.engine.runKernel(function (backend) { return backend.logicalOr(a, b); }, { a: a, b: b });\n    };\n    LogicalOps.logicalXor = function (a, b) {\n        util.assertArgumentsAreTensors({ a: a, b: b }, 'logicalXor');\n        util.assert(a.dtype === 'bool' && b.dtype === 'bool', 'Error Array must be of type bool.');\n        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);\n        return LogicalOps.logicalOr(a, b).logicalAnd(LogicalOps.logicalAnd(a, b).logicalNot());\n    };\n    LogicalOps.where = function (condition, a, b) {\n        util.assertArgumentsAreTensors({ condition: condition, a: a, b: b }, 'where');\n        util.assert(condition.dtype === 'bool' || a.dtype === 'bool' || b.dtype === 'bool', 'Error Array must be of type bool.');\n        util.assertShapesMatch(a.shape, b.shape, 'Error in where: ');\n        if (condition.rank === 1) {\n            util.assert(condition.shape[0] === a.shape[0], 'The first dimension of `a` must match the size of `condition`.');\n        }\n        else {\n            util.assertShapesMatch(condition.shape, b.shape, 'Error in where: ');\n        }\n        var dtype = types.upcastType(a.dtype, b.dtype);\n        return environment_1.ENV.engine.runKernel(function (backend) { return backend.where(condition, a, b, dtype); }, { condition: condition, a: a, b: b });\n    };\n    __decorate([\n        doc_1.doc({ heading: 'Operations', subheading: 'Logical' }),\n        operation_1.operation\n    ], LogicalOps, \"logicalNot\", null);\n    __decorate([\n        doc_1.doc({ heading: 'Operations', subheading: 'Logical' }),\n        operation_1.operation\n    ], LogicalOps, \"logicalAnd\", null);\n    __decorate([\n        doc_1.doc({ heading: 'Operations', subheading: 'Logical' }),\n        operation_1.operation\n    ], LogicalOps, \"logicalOr\", null);\n    __decorate([\n        doc_1.doc({ heading: 'Operations', subheading: 'Logical' }),\n        operation_1.operation\n    ], LogicalOps, \"logicalXor\", null);\n    __decorate([\n        doc_1.doc({ heading: 'Operations', subheading: 'Logical' }),\n        operation_1.operation\n    ], LogicalOps, \"where\", null);\n    return LogicalOps;\n}());\nexports.LogicalOps = LogicalOps;\n","map":{"version":3,"file":"logical_ops.js","sourceRoot":"","sources":["../src/ops/logical_ops.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {doc} from '../doc';\nimport {ENV} from '../environment';\nimport {Tensor} from '../tensor';\nimport * as types from '../types';\nimport * as util from '../util';\nimport * as broadcast_util from './broadcast_util';\nimport {operation} from './operation';\n\nexport class LogicalOps {\n  /**\n   * Returns the truth value of `NOT x` element-wise.\n   *\n   * ```js\n   * const a = tf.tensor1d([false, true], 'bool');\n   *\n   * a.logicalNot().print();\n   * ```\n   *\n   * @param x The input tensor. Must be of dtype 'bool'.\n   */\n  @doc({heading: 'Operations', subheading: 'Logical'})\n  @operation\n  static logicalNot<T extends Tensor>(x: T): T {\n    util.assertArgumentsAreTensors({x}, 'logicalNot');\n    util.assert(x.dtype === 'bool', 'Error Array must be of type bool.');\n\n    return ENV.engine.runKernel(backend => backend.logicalNot(x), {x});\n  }\n\n  /**\n   * Returns the truth value of a AND b element-wise. Supports broadcasting.\n   *\n   * ```js\n   * const a = tf.tensor1d([false, false, true, true], 'bool');\n   * const b = tf.tensor1d([false, true, false, true], 'bool');\n   *\n   * a.logicalAnd(b).print();\n   * ```\n   *\n   * @param a The first input tensor. Must be of dtype bool.\n   * @param b The second input tensor. Must be of dtype bool.\n   */\n  @doc({heading: 'Operations', subheading: 'Logical'})\n  @operation\n  static logicalAnd<T extends Tensor>(a: Tensor, b: Tensor): T {\n    util.assertArgumentsAreTensors({a, b}, 'logicalAnd');\n    util.assert(\n        a.dtype === 'bool' && b.dtype === 'bool',\n        'Error Array must be of type bool.');\n    broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);\n\n    return ENV.engine.runKernel(backend => backend.logicalAnd(a, b), {a, b}) as\n        T;\n  }\n\n  /**\n   * Returns the truth value of `a OR b` element-wise. Supports broadcasting.\n   *\n   * ```js\n   * const a = tf.tensor1d([false, false, true, true], 'bool');\n   * const b = tf.tensor1d([false, true, false, true], 'bool');\n   *\n   * a.logicalOr(b).print();\n   * ```\n   * @param a The first input tensor. Must be of dtype bool.\n   * @param b The second input tensor. Must be of dtype bool.\n   */\n  @doc({heading: 'Operations', subheading: 'Logical'})\n  @operation\n  static logicalOr<T extends Tensor>(a: Tensor, b: Tensor): T {\n    util.assertArgumentsAreTensors({a, b}, 'logicalOr');\n    util.assert(\n        a.dtype === 'bool' && b.dtype === 'bool',\n        'Error Array must be of type bool.');\n    broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);\n\n    return ENV.engine.runKernel(backend => backend.logicalOr(a, b), {a, b}) as\n        T;\n  }\n\n  /**\n   * Returns the truth value of `a XOR b` element-wise. Supports broadcasting.\n   *\n   * ```js\n   * const a = tf.tensor1d([false, false, true, true], 'bool');\n   * const b = tf.tensor1d([false, true, false, true], 'bool');\n   *\n   * a.logicalXor(b).print();\n   * ```\n   *\n   * @param a The first input tensor. Must be of dtype bool.\n   * @param b The second input tensor. Must be of dtype bool.\n   */\n  @doc({heading: 'Operations', subheading: 'Logical'})\n  @operation\n  static logicalXor<T extends Tensor>(a: Tensor, b: Tensor): T {\n    util.assertArgumentsAreTensors({a, b}, 'logicalXor');\n    util.assert(\n        a.dtype === 'bool' && b.dtype === 'bool',\n        'Error Array must be of type bool.');\n    broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);\n\n    // x ^ y = (x | y) & ~(x & y)\n    return LogicalOps.logicalOr(a, b).logicalAnd(\n               LogicalOps.logicalAnd(a, b).logicalNot()) as T;\n  }\n\n  /**\n   * Returns the elements, either `a` or `b` depending on the `condition`.\n   *\n   * If the condition is true, select from `a`, otherwise select from `b`.\n   *\n   * ```js\n   * const cond = tf.tensor1d([false, false, true], 'bool');\n   * const a = tf.tensor1d([1 , 2, 3]);\n   * const b = tf.tensor1d([-1, -2, -3]);\n   *\n   * a.where(cond, b).print();\n   * ```\n   *\n   * @param condition The input condition. Must be of dtype bool.\n   * @param a If `condition` is rank 1, `a` may have a higher rank but\n   *     its first dimension must match the size of `condition`.\n   * @param b A tensor with the same shape and type as `a`.\n   */\n  @doc({heading: 'Operations', subheading: 'Logical'})\n  @operation\n  static where<T extends Tensor>(condition: Tensor, a: T, b: T): T {\n    util.assertArgumentsAreTensors({condition, a, b}, 'where');\n    util.assert(\n        condition.dtype === 'bool' || a.dtype === 'bool' || b.dtype === 'bool',\n        'Error Array must be of type bool.');\n    util.assertShapesMatch(a.shape, b.shape, 'Error in where: ');\n\n    if (condition.rank === 1) {\n      // If condition rank is 1, then the first dimension must match the size of\n      // condition.\n      util.assert(\n          condition.shape[0] === a.shape[0],\n          'The first dimension of `a` must match the size of `condition`.');\n    } else {\n      // A must have the same shape as condition.\n      util.assertShapesMatch(condition.shape, b.shape, 'Error in where: ');\n    }\n\n    // Default to highest percision of number:\n    const dtype = types.upcastType(a.dtype, b.dtype);\n    return ENV.engine.runKernel(\n               backend => backend.where(condition, a, b, dtype),\n               {condition, a, b}) as T;\n  }\n}\n"]}},"hash":"389c0a8fa8e4b866ae9e5cd3079530cf","cacheData":{"env":{}}}