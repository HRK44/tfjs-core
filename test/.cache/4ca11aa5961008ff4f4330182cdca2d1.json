{"dependencies":[{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/float16/tfjs-core/test/package.json","includedInParent":true,"mtime":1528810356568},{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/float16/tfjs-core/test/.babelrc","includedInParent":true,"mtime":1525096773813},{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/float16/tfjs-core/tsconfig.json","includedInParent":true,"mtime":1528810356568},{"name":"../../ops/broadcast_util","loc":{"line":3,"column":29}},{"name":"../../util","loc":{"line":4,"column":19}}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar broadcast_util = require(\"../../ops/broadcast_util\");\nvar util = require(\"../../util\");\nfunction makeShader(inputsInfo, outputShape, userCode, broadcast) {\n    var inputPrefixSnippet = inputsInfo.map(function (x) {\n        var size = util.sizeFromShape(x.shapeInfo.logicalShape);\n        if (x.shapeInfo.isUniform) {\n            return \"uniform float \" + x.name + (size > 1 ? \"[\" + size + \"]\" : '') + \";\";\n        }\n        return \"uniform sampler2D \" + x.name + \";\";\n    });\n    inputPrefixSnippet = inputPrefixSnippet.join('\\n');\n    var inputSamplingSnippet = inputsInfo.map(function (x) { return getInputSamplingSnippet(x, outputShape, broadcast); })\n        .join('\\n');\n    var outTexShape = outputShape.texShape;\n    var outputSamplingSnippet = getOutputSamplingSnippet(outputShape.logicalShape, outTexShape);\n    var source = [\n        SHADER_PREFIX, FLOAT_TEXTURE_SAMPLE_SNIPPET,\n        FLOAT_TEXTURE_SETOUTPUT_SNIPPET, inputPrefixSnippet, outputSamplingSnippet,\n        inputSamplingSnippet, userCode\n    ].join('\\n');\n    return source;\n}\nexports.makeShader = makeShader;\nfunction getSamplerFromInInfo(inInfo) {\n    var shape = inInfo.shapeInfo.logicalShape;\n    switch (shape.length) {\n        case 0:\n            return getSamplerScalar(inInfo);\n        case 1:\n            return getSampler1D(inInfo);\n        case 2:\n            return getSampler2D(inInfo);\n        case 3:\n            return getSampler3D(inInfo);\n        case 4:\n            return getSampler4D(inInfo);\n        case 5:\n            return getSampler5D(inInfo);\n        default:\n            throw new Error(shape.length + \"-D input sampling\" +\n                \" is not yet supported\");\n    }\n}\nfunction getInputSamplingSnippet(inInfo, outShapeInfo, broadcast) {\n    var res = getSamplerFlat(inInfo);\n    res += getSamplerFromInInfo(inInfo);\n    if (broadcast ||\n        util.arraysEqual(inInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape)) {\n        res += getSamplerAtOutputCoords(inInfo, outShapeInfo, broadcast);\n    }\n    return res;\n}\nfunction getOutputSamplingSnippet(outShape, outTexShape) {\n    switch (outShape.length) {\n        case 0:\n            return getOutputScalarCoords();\n        case 1:\n            return getOutput1DCoords(outShape, outTexShape);\n        case 2:\n            return getOutput2DCoords(outShape, outTexShape);\n        case 3:\n            return getOutput3DCoords(outShape, outTexShape);\n        case 4:\n            return getOutput4DCoords(outShape, outTexShape);\n        case 5:\n            return getOutput5DCoords(outShape, outTexShape);\n        default:\n            throw new Error(outShape.length + \"-D output sampling is not yet supported\");\n    }\n}\nvar SAMPLE_1D_SNIPPET = \"\\nvec2 UVfrom1D(int texNumR, int texNumC, int index) {\\n  int texR = index / texNumC;\\n  int texC = index - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\";\nvar SAMPLE_2D_SNIPPET = \"\\nvec2 UVfrom2D(int texNumR, int texNumC, int numC, int row, int col) {\\n  int index = row * numC + col;\\n  int texR = index / texNumC;\\n  int texC = index - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\";\nvar SAMPLE_3D_SNIPPET = \"\\nvec2 UVfrom3D(int texNumR, int texNumC, int stride0,\\n    int stride1, int row, int col, int depth) {\\n  // Explicitly use integer operations as dot() only works on floats.\\n  int index = row * stride0 + col * stride1 + depth;\\n  int texR = index / texNumC;\\n  int texC = index - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\";\nvar SAMPLE_4D_SNIPPET = \"\\nvec2 UVfrom4D(int texNumR, int texNumC, int stride0,\\n    int stride1, int stride2, int row, int col, int depth,\\n    int depth2) {\\n  // Explicitly use integer operations as dot() only works on floats.\\n  int index = row * stride0 + col * stride1 + depth * stride2 + depth2;\\n  int texR = index / texNumC;\\n  int texC = index - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\";\nvar SAMPLE_5D_SNIPPET = \"\\nvec2 UVfrom5D(int texNumR, int texNumC, int stride0,\\n    int stride1, int stride2, int stride3, int row, int col, int depth,\\n    int depth2, int depth3) {\\n  // Explicitly use integer operations as dot() only works on floats.\\n  int index = row * stride0 + col * stride1 +\\n              depth * stride2 + depth2 * stride3 + depth3;\\n  int texR = index / texNumC;\\n  int texC = index - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\";\nvar FLOAT_TEXTURE_SAMPLE_SNIPPET = \"\\n  float sampleTexture(sampler2D textureSampler, vec2 uv) {\\n    return texture2D(textureSampler, uv).r;\\n  }\\n\";\nvar FLOAT_TEXTURE_SETOUTPUT_SNIPPET = \"\\n  void setOutput(float val) {\\n    gl_FragColor = vec4(val, 0, 0, 0);\\n  }\\n\";\nvar SHADER_PREFIX = \"\\n  precision highp float;\\n  precision highp int;\\n  varying vec2 resultUV;\\n  const vec2 halfCR = vec2(0.5, 0.5);\\n\\n  struct ivec5\\n  {\\n    int x;\\n    int y;\\n    int z;\\n    int w;\\n    int u;\\n  };\\n\\n  bool isNaN(float val) {\\n    float v1 = val * val;\\n    float v2 = val * val;\\n    return v1 == v2 ? false : true;\\n  }\\n\\n  bool hasNaN(vec4 values) {\\n    vec4 v1 = values * values;\\n    vec4 v2 = values * values;\\n    return any(notEqual(v1, v2));\\n  }\\n\\n  float getNaN(vec4 values) {\\n    return dot(vec4(1), values);\\n  }\\n\\n  int round(float value) {\\n    return int(floor(value + 0.5));\\n  }\\n\\n  int imod(int x, int y) {\\n    return x - y * (x / y);\\n  }\\n\\n  //Based on the work of Dave Hoskins\\n  //https://www.shadertoy.com/view/4djSRW\\n  #define HASHSCALE1 443.8975\\n  float random(float seed){\\n    vec2 p = resultUV * seed;\\n    vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\\n    p3 += dot(p3, p3.yzx + 19.19);\\n    return fract((p3.x + p3.y) * p3.z);\\n  }\\n\\n  \" + SAMPLE_1D_SNIPPET + \"\\n  \" + SAMPLE_2D_SNIPPET + \"\\n  \" + SAMPLE_3D_SNIPPET + \"\\n  \" + SAMPLE_4D_SNIPPET + \"\\n  \" + SAMPLE_5D_SNIPPET + \"\\n\";\nfunction getOutputScalarCoords() {\n    return \"\\n    int getOutputCoords() {\\n      return 0;\\n    }\\n  \";\n}\nfunction getOutput1DCoords(shape, texShape) {\n    if (texShape[0] === 1) {\n        return \"\\n      int getOutputCoords() {\\n        return int(resultUV.x * \" + texShape[1] + \".0);\\n      }\\n    \";\n    }\n    if (texShape[1] === 1) {\n        return \"\\n      int getOutputCoords() {\\n        return int(resultUV.y * \" + texShape[0] + \".0);\\n      }\\n    \";\n    }\n    return \"\\n    int getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + texShape[0] + \", \" + texShape[1] + \"));\\n      return resTexRC.x * \" + texShape[1] + \" + resTexRC.y;\\n    }\\n  \";\n}\nfunction getOutput3DCoords(shape, texShape) {\n    var stride0 = shape[1] * shape[2];\n    var stride1 = shape[2];\n    return \"\\n    ivec3 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + texShape[0] + \", \" + texShape[1] + \"));\\n      int index = resTexRC.x * \" + texShape[1] + \" + resTexRC.y;\\n      int r = index / \" + stride0 + \";\\n      index -= r * \" + stride0 + \";\\n      int c = index / \" + stride1 + \";\\n      int d = index - c * \" + stride1 + \";\\n      return ivec3(r, c, d);\\n    }\\n  \";\n}\nfunction getOutput4DCoords(shape, texShape) {\n    var stride2 = shape[3];\n    var stride1 = shape[2] * stride2;\n    var stride0 = shape[1] * stride1;\n    return \"\\n    ivec4 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n        vec2(\" + texShape[0] + \", \" + texShape[1] + \"));\\n      int index = resTexRC.x * \" + texShape[1] + \" + resTexRC.y;\\n\\n      int r = index / \" + stride0 + \";\\n      index -= r * \" + stride0 + \";\\n\\n      int c = index / \" + stride1 + \";\\n      index -= c * \" + stride1 + \";\\n\\n      int d = index / \" + stride2 + \";\\n      int d2 = index - d * \" + stride2 + \";\\n\\n      return ivec4(r, c, d, d2);\\n    }\\n  \";\n}\nfunction getOutput5DCoords(shape, texShape) {\n    var stride3 = shape[4];\n    var stride2 = shape[3] * stride3;\n    var stride1 = shape[2] * stride2;\n    var stride0 = shape[1] * stride1;\n    return \"\\n    ivec5 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(\" + texShape[0] + \",\\n                             \" + texShape[1] + \"));\\n\\n      int index = resTexRC.x * \" + texShape[1] + \" + resTexRC.y;\\n\\n      int r = index / \" + stride0 + \";\\n      index -= r * \" + stride0 + \";\\n\\n      int c = index / \" + stride1 + \";\\n      index -= c * \" + stride1 + \";\\n\\n      int d = index / \" + stride2 + \";\\n      index -= d * \" + stride2 + \";\\n\\n      int d2 = index  / \" + stride3 + \";\\n      int d3 = index - d2 * \" + stride3 + \";\\n\\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\\n      return outShape;\\n    }\\n  \";\n}\nfunction getOutput2DCoords(shape, texShape) {\n    if (util.arraysEqual(shape, texShape)) {\n        return \"\\n      ivec2 getOutputCoords() {\\n        return ivec2(resultUV.yx * vec2(\" + texShape[0] + \", \" + texShape[1] + \"));\\n      }\\n    \";\n    }\n    if (shape[1] === 1) {\n        return \"\\n      ivec2 getOutputCoords() {\\n        ivec2 resTexRC = ivec2(resultUV.yx *\\n                               vec2(\" + texShape[0] + \", \" + texShape[1] + \"));\\n        int index = resTexRC.x * \" + texShape[1] + \" + resTexRC.y;\\n        return ivec2(index, 0);\\n      }\\n    \";\n    }\n    if (shape[0] === 1) {\n        return \"\\n      ivec2 getOutputCoords() {\\n        ivec2 resTexRC = ivec2(resultUV.yx *\\n                               vec2(\" + texShape[0] + \", \" + texShape[1] + \"));\\n        int index = resTexRC.x * \" + texShape[1] + \" + resTexRC.y;\\n        return ivec2(0, index);\\n      }\\n    \";\n    }\n    return \"\\n    ivec2 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + texShape[0] + \", \" + texShape[1] + \"));\\n      int index = resTexRC.x * \" + texShape[1] + \" + resTexRC.y;\\n      int r = index / \" + shape[1] + \";\\n      int c = index - r * \" + shape[1] + \";\\n      return ivec2(r, c);\\n    }\\n  \";\n}\nfunction getSamplerScalar(inputInfo) {\n    var texName = inputInfo.name;\n    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    if (inputInfo.shapeInfo.isUniform) {\n        return \"float \" + funcName + \"() {return \" + texName + \";}\";\n    }\n    return \"\\n    float \" + funcName + \"() {\\n      return sampleTexture(\" + texName + \", halfCR);\\n    }\\n  \";\n}\nfunction getSampler1D(inputInfo) {\n    var texName = inputInfo.name;\n    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    return \"\\n    float \" + funcName + \"(int index) {\\n      return \" + funcName + \"Flat(index);\\n    }\\n  \";\n}\nfunction getSampler2D(inputInfo) {\n    var shape = inputInfo.shapeInfo.logicalShape;\n    var texName = inputInfo.name;\n    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    var texShape = inputInfo.shapeInfo.texShape;\n    if (texShape != null && util.arraysEqual(shape, texShape)) {\n        var texNumR_1 = texShape[0];\n        var texNumC_1 = texShape[1];\n        return \"\\n    float \" + funcName + \"(int row, int col) {\\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(\" + texNumC_1 + \".0, \" + texNumR_1 + \".0);\\n      return sampleTexture(\" + texName + \", uv);\\n    }\\n  \";\n    }\n    var _a = util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;\n    var squeezedShape = newShape;\n    if (squeezedShape.length < shape.length) {\n        var newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);\n        var params = ['row', 'col'];\n        return \"\\n      \" + getSamplerFromInInfo(newInputInfo) + \"\\n      float \" + funcName + \"(int row, int col) {\\n        return \" + funcName + \"(\" + getSqueezedParams(params, keptDims) + \");\\n      }\\n    \";\n    }\n    if (inputInfo.shapeInfo.isUniform) {\n        return \"\\n      float \" + funcName + \"(int row, int col) {\\n        int index = row * \" + shape[1] + \" + col;\\n        return \" + funcName + \"Flat(index);\\n      }\\n    \";\n    }\n    var texNumR = texShape[0];\n    var texNumC = texShape[1];\n    if (texNumC === 1) {\n        return \"\\n    float \" + funcName + \"(int row, int col) {\\n      int index = row * \" + shape[1] + \" + col;\\n      vec2 uv = vec2(0.5, (float(index) + 0.5) / \" + texNumR + \".0);\\n      return sampleTexture(\" + texName + \", uv);\\n    }\\n  \";\n    }\n    if (texNumR === 1) {\n        return \"\\n    float \" + funcName + \"(int row, int col) {\\n      int index = row * \" + shape[1] + \" + col;\\n      vec2 uv = vec2((float(index) + 0.5) / \" + texNumC + \".0, 0.5);\\n      return sampleTexture(\" + texName + \", uv);\\n    }\\n  \";\n    }\n    return \"\\n  float \" + funcName + \"(int row, int col) {\\n    vec2 uv = UVfrom2D(\" + texNumR + \", \" + texNumC + \", \" + shape[1] + \", row, col);\\n    return sampleTexture(\" + texName + \", uv);\\n  }\\n\";\n}\nfunction getSampler3D(inputInfo) {\n    var shape = inputInfo.shapeInfo.logicalShape;\n    var texName = inputInfo.name;\n    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    var stride0 = shape[1] * shape[2];\n    var stride1 = shape[2];\n    var _a = util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;\n    var squeezedShape = newShape;\n    if (squeezedShape.length < shape.length) {\n        var newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);\n        var params = ['row', 'col', 'depth'];\n        return \"\\n        \" + getSamplerFromInInfo(newInputInfo) + \"\\n        float \" + funcName + \"(int row, int col, int depth) {\\n          return \" + funcName + \"(\" + getSqueezedParams(params, keptDims) + \");\\n        }\\n      \";\n    }\n    if (inputInfo.shapeInfo.isUniform) {\n        return \"\\n      float \" + funcName + \"(int row, int col, int depth) {\\n        int index = row * \" + stride0 + \" + col * \" + stride1 + \" + depth;\\n        return \" + funcName + \"Flat(index);\\n      }\\n    \";\n    }\n    var texShape = inputInfo.shapeInfo.texShape;\n    var texNumR = texShape[0];\n    var texNumC = texShape[1];\n    if (texNumC === stride0) {\n        return \"\\n        float \" + funcName + \"(int row, int col, int depth) {\\n          int texR = row;\\n          int texC = col * \" + stride1 + \" + depth;\\n          vec2 uv = (vec2(texC, texR) + halfCR) /\\n                     vec2(\" + texNumC + \".0, \" + texNumR + \".0);\\n          return sampleTexture(\" + texName + \", uv);\\n        }\\n      \";\n    }\n    if (texNumC === stride1) {\n        return \"\\n    float \" + funcName + \"(int row, int col, int depth) {\\n      int texR = row * \" + shape[1] + \" + col;\\n      int texC = depth;\\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(\" + texNumC + \".0, \" + texNumR + \".0);\\n      return sampleTexture(\" + texName + \", uv);\\n    }\\n  \";\n    }\n    return \"\\n      float \" + funcName + \"(int row, int col, int depth) {\\n        vec2 uv = UVfrom3D(\\n            \" + texNumR + \", \" + texNumC + \", \" + stride0 + \", \" + stride1 + \", row, col, depth);\\n        return sampleTexture(\" + texName + \", uv);\\n      }\\n  \";\n}\nfunction getSampler4D(inputInfo) {\n    var shape = inputInfo.shapeInfo.logicalShape;\n    var texName = inputInfo.name;\n    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    var stride2 = shape[3];\n    var stride1 = shape[2] * stride2;\n    var stride0 = shape[1] * stride1;\n    var _a = util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;\n    if (newShape.length < shape.length) {\n        var newInputInfo = squeezeInputInfo(inputInfo, newShape);\n        var params = ['row', 'col', 'depth', 'depth2'];\n        return \"\\n      \" + getSamplerFromInInfo(newInputInfo) + \"\\n      float \" + funcName + \"(int row, int col, int depth, int depth2) {\\n        return \" + funcName + \"(\" + getSqueezedParams(params, keptDims) + \");\\n      }\\n    \";\n    }\n    if (inputInfo.shapeInfo.isUniform) {\n        return \"\\n      float \" + funcName + \"(int row, int col, int depth, int depth2) {\\n        int index = row * \" + stride0 + \" + col * \" + stride1 + \" +\\n            depth * \" + stride2 + \" + depth2;\\n        return \" + funcName + \"Flat(index);\\n      }\\n    \";\n    }\n    var texShape = inputInfo.shapeInfo.texShape;\n    var texNumR = texShape[0];\n    var texNumC = texShape[1];\n    if (texNumC === stride0) {\n        return \"\\n      float \" + funcName + \"(int row, int col, int depth, int depth2) {\\n        int texR = row;\\n        int texC = col * \" + stride1 + \" + depth * \" + stride2 + \" + depth2;\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                   vec2(\" + texNumC + \".0, \" + texNumR + \".0);\\n        return sampleTexture(\" + texName + \", uv);\\n      }\\n    \";\n    }\n    if (texNumC === stride2) {\n        return \"\\n      float \" + funcName + \"(int row, int col, int depth, int depth2) {\\n        int texR = row * \" + shape[1] * shape[2] + \" + col * \" + shape[2] + \" + depth;\\n        int texC = depth2;\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                  vec2(\" + texNumC + \".0, \" + texNumR + \".0);\\n        return sampleTexture(\" + texName + \", uv);\\n      }\\n    \";\n    }\n    return \"\\n    float \" + funcName + \"(int row, int col, int depth, int depth2) {\\n      vec2 uv = UVfrom4D(\" + texNumR + \", \" + texNumC + \", \" + stride0 + \", \" + stride1 + \",\\n          \" + stride2 + \", row, col, depth, depth2);\\n      return sampleTexture(\" + texName + \", uv);\\n    }\\n  \";\n}\nfunction getSampler5D(inputInfo) {\n    var shape = inputInfo.shapeInfo.logicalShape;\n    var texName = inputInfo.name;\n    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    var stride3 = shape[4];\n    var stride2 = shape[3] * stride3;\n    var stride1 = shape[2] * stride2;\n    var stride0 = shape[1] * stride1;\n    var _a = util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;\n    if (newShape.length < shape.length) {\n        var newInputInfo = squeezeInputInfo(inputInfo, newShape);\n        var params = ['row', 'col', 'depth', 'depth2', 'depth3'];\n        return \"\\n      \" + getSamplerFromInInfo(newInputInfo) + \"\\n      float \" + funcName + \"(int row, int col, int depth, int depth2, int depth3) {\\n        return \" + funcName + \"(\" + getSqueezedParams(params, keptDims) + \");\\n      }\\n    \";\n    }\n    if (inputInfo.shapeInfo.isUniform) {\n        return \"\\n      float \" + funcName + \"(int row, int col, int depth, int depth2, int depth3) {\\n        int index = row * \" + stride0 + \" + col * \" + stride1 + \" +\\n            depth * \" + stride2 + \" + depth2 * \" + stride3 + \" + depth3;\\n        return \" + funcName + \"Flat(index);\\n      }\\n    \";\n    }\n    var texShape = inputInfo.shapeInfo.texShape;\n    var texNumR = texShape[0];\n    var texNumC = texShape[1];\n    if (texNumC === stride0) {\n        return \"\\n      float \" + funcName + \"(int row, int col, int depth, int depth2, int depth3) {\\n        int texR = row;\\n        int texC = col * \" + stride1 + \" + depth * \" + stride2 + \" +\\n                   depth2 * \" + stride3 + \" + depth3;\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                   vec2(\" + texNumC + \".0, \" + texNumR + \".0);\\n        return sampleTexture(\" + texName + \", uv);\\n      }\\n    \";\n    }\n    if (texNumC === stride3) {\n        return \"\\n      float \" + funcName + \"(int row, int col, int depth, int depth2, int depth3) {\\n        int texR = row * \" + shape[1] * shape[2] + \" + col * \" + shape[2] + \" +\\n                   depth * \" + shape[3] + \" + depth2;\\n        int texC = depth3;\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                  vec2(\" + texNumC + \".0, \" + texNumR + \".0);\\n        return sampleTexture(\" + texName + \", uv);\\n      }\\n    \";\n    }\n    return \"\\n    float \" + funcName + \"(int row, int col, int depth, int depth2, int depth3) {\\n      vec2 uv = UVfrom5D(\" + texNumR + \", \" + texNumC + \", \" + stride0 + \", \" + stride1 + \",\\n          \" + stride2 + \", \" + stride3 + \", row, col, depth, depth2, depth3);\\n      return sampleTexture(\" + texName + \", uv);\\n    }\\n  \";\n}\nfunction getSamplerFlat(inputInfo) {\n    var texName = inputInfo.name;\n    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1) + 'Flat';\n    var inSize = util.sizeFromShape(inputInfo.shapeInfo.logicalShape);\n    if (inputInfo.shapeInfo.isUniform) {\n        if (inSize === 1) {\n            return \"float \" + funcName + \"(int index) {return \" + texName + \";}\";\n        }\n        return \"\\n      float \" + funcName + \"(int index) {\\n        for (int i = 0; i < \" + inSize + \"; i++) {\\n          if (i == index) {\\n            return \" + texName + \"[i];\\n          }\\n        }\\n      }\\n    \";\n    }\n    var texShape = inputInfo.shapeInfo.texShape;\n    var tNumR = texShape[0];\n    var tNumC = texShape[1];\n    if (tNumC === 1 && tNumR === 1) {\n        return \"\\n      float \" + funcName + \"(int index) {\\n        return sampleTexture(\" + texName + \", halfCR);\\n      }\\n    \";\n    }\n    if (tNumC === 1) {\n        return \"\\n      float \" + funcName + \"(int index) {\\n        vec2 uv = vec2(0.5, (float(index) + 0.5) / \" + tNumR + \".0);\\n        return sampleTexture(\" + texName + \", uv);\\n      }\\n    \";\n    }\n    if (tNumR === 1) {\n        return \"\\n      float \" + funcName + \"(int index) {\\n        vec2 uv = vec2((float(index) + 0.5) / \" + tNumC + \".0, 0.5);\\n        return sampleTexture(\" + texName + \", uv);\\n      }\\n    \";\n    }\n    return \"\\n    float \" + funcName + \"(int index) {\\n      vec2 uv = UVfrom1D(\" + tNumR + \", \" + tNumC + \", index);\\n      return sampleTexture(\" + texName + \", uv);\\n    }\\n  \";\n}\nfunction getBroadcastOutputCoordsSampler(inputInfo, outShapeInfo, texFuncSnippet, funcName) {\n    var inRank = inputInfo.shapeInfo.logicalShape.length;\n    var outRank = outShapeInfo.logicalShape.length;\n    var type = 'int';\n    if (outRank === 2) {\n        type = 'ivec2';\n    }\n    else if (outRank === 3) {\n        type = 'ivec3';\n    }\n    else if (outRank === 4) {\n        type = 'ivec4';\n    }\n    var broadcastDims = broadcast_util.getBroadcastDims(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);\n    var rankDiff = outRank - inRank;\n    var coordsSnippet;\n    if (inRank === 0) {\n        coordsSnippet = '';\n    }\n    else if (outRank < 2 && broadcastDims.length >= 1) {\n        coordsSnippet = 'coords = 0;';\n    }\n    else {\n        coordsSnippet =\n            broadcastDims.map(function (d) { return \"coords[\" + (d + rankDiff) + \"] = 0;\"; }).join('\\n');\n    }\n    var unpackedCoordsSnippet = '';\n    if (outRank < 2 && inRank > 0) {\n        unpackedCoordsSnippet = 'coords';\n    }\n    else {\n        unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape\n            .map(function (s, i) { return \"coords[\" + (i + rankDiff) + \"]\"; })\n            .join(', ');\n    }\n    return \"\\n    float \" + funcName + \"() {\\n      \" + type + \" coords = getOutputCoords();\\n      \" + coordsSnippet + \"\\n      return get\" + texFuncSnippet + \"(\" + unpackedCoordsSnippet + \");\\n    }\\n  \";\n}\nfunction getSamplerAtOutputCoords(inputInfo, outShapeInfo, supportsBroadcasting) {\n    var texName = inputInfo.name;\n    var texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);\n    var funcName = 'get' + texFuncSnippet + 'AtOutCoords';\n    var broadcastDims = broadcast_util.getBroadcastDims(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);\n    var inRank = inputInfo.shapeInfo.logicalShape.length;\n    var outRank = outShapeInfo.logicalShape.length;\n    var doBroadcast = supportsBroadcasting && ((outRank > inRank) || broadcastDims.length > 0);\n    var broadcastOverOuter = broadcast_util.broadcastDimsAreOuter(broadcastDims);\n    var isUniform = inputInfo.shapeInfo.isUniform;\n    if (doBroadcast && !broadcastOverOuter) {\n        return getBroadcastOutputCoordsSampler(inputInfo, outShapeInfo, texFuncSnippet, funcName);\n    }\n    var inSize = util.sizeFromShape(inputInfo.shapeInfo.logicalShape);\n    var broadcastSnippet = '';\n    if (doBroadcast && broadcastOverOuter) {\n        broadcastSnippet = \"\\n        int mainPart = index / \" + inSize + \";\\n        index -= mainPart * \" + inSize + \";\\n      \";\n    }\n    var outTexShape = outShapeInfo.texShape;\n    if (isUniform) {\n        if (inSize === 1) {\n            return \"float \" + funcName + \"() {return \" + texName + \";}\";\n        }\n        return \"\\n      float \" + funcName + \"() {\\n        ivec2 resTexRC = ivec2(resultUV.yx *\\n                              vec2(\" + outTexShape[0] + \", \" + outTexShape[1] + \"));\\n        int index = resTexRC.x * \" + outTexShape[1] + \" + resTexRC.y;\\n        \" + broadcastSnippet + \"\\n        return get\" + texFuncSnippet + \"Flat(index);\\n      }\\n    \";\n    }\n    var inTexShape = inputInfo.shapeInfo.texShape;\n    if (util.arraysEqual(inTexShape, outTexShape)) {\n        return \"\\n      float \" + funcName + \"() {\\n        return sampleTexture(\" + texName + \", resultUV);\\n      }\\n    \";\n    }\n    return \"\\n    float \" + funcName + \"() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + outTexShape[0] + \", \" + outTexShape[1] + \"));\\n      int index = resTexRC.x * \" + outTexShape[1] + \" + resTexRC.y;\\n      \" + broadcastSnippet + \"\\n      int texR = index / \" + inTexShape[1] + \";\\n      int texC = index - texR * \" + inTexShape[1] + \";\\n      vec2 uv = (vec2(texC, texR) + halfCR) /\\n                 vec2(\" + inTexShape[1] + \".0, \" + inTexShape[0] + \".0);\\n\\n      return sampleTexture(\" + texName + \", uv);\\n    }\\n  \";\n}\nfunction getCoordsDataType(rank) {\n    if (rank <= 1) {\n        return 'int';\n    }\n    else if (rank === 2) {\n        return 'ivec2';\n    }\n    else if (rank === 3) {\n        return 'ivec3';\n    }\n    else if (rank === 4) {\n        return 'ivec4';\n    }\n    else if (rank === 5) {\n        return 'ivec5';\n    }\n    else {\n        throw Error(\"GPU for rank \" + rank + \" is not yet supported\");\n    }\n}\nexports.getCoordsDataType = getCoordsDataType;\nfunction squeezeInputInfo(inInfo, squeezedShape) {\n    var newInputInfo = JSON.parse(JSON.stringify(inInfo));\n    newInputInfo.shapeInfo.logicalShape = squeezedShape;\n    return newInputInfo;\n}\nfunction getSqueezedParams(params, keptDims) {\n    return keptDims.map(function (d) { return params[d]; }).join(', ');\n}\n","map":{"version":3,"file":"shader_compiler.js","sourceRoot":"","sources":["../src/kernels/webgl/shader_compiler.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as broadcast_util from '../../ops/broadcast_util';\nimport * as util from '../../util';\n\nexport type ShapeInfo = {\n  logicalShape: number[],\n  texShape: [number, number],\n  isUniform: boolean\n};\n\nexport type InputInfo = {\n  name: string,\n  shapeInfo: ShapeInfo\n};\n\nexport function makeShader(\n    inputsInfo: InputInfo[], outputShape: ShapeInfo, userCode: string,\n    broadcast: boolean): string {\n  let inputPrefixSnippet: string[]|string = inputsInfo.map(x => {\n    const size = util.sizeFromShape(x.shapeInfo.logicalShape);\n    if (x.shapeInfo.isUniform) {\n      return `uniform float ${x.name}${size > 1 ? `[${size}]` : ''};`;\n    }\n    return `uniform sampler2D ${x.name};`;\n  });\n  inputPrefixSnippet = inputPrefixSnippet.join('\\n');\n  const inputSamplingSnippet =\n      inputsInfo.map(x => getInputSamplingSnippet(x, outputShape, broadcast))\n          .join('\\n');\n  const outTexShape = outputShape.texShape;\n  const outputSamplingSnippet =\n      getOutputSamplingSnippet(outputShape.logicalShape, outTexShape);\n  const source = [\n    SHADER_PREFIX, FLOAT_TEXTURE_SAMPLE_SNIPPET,\n    FLOAT_TEXTURE_SETOUTPUT_SNIPPET, inputPrefixSnippet, outputSamplingSnippet,\n    inputSamplingSnippet, userCode\n  ].join('\\n');\n  return source;\n}\n\nfunction getSamplerFromInInfo(inInfo: InputInfo): string {\n  const shape = inInfo.shapeInfo.logicalShape;\n  switch (shape.length) {\n    case 0:\n      return getSamplerScalar(inInfo);\n    case 1:\n      return getSampler1D(inInfo);\n    case 2:\n      return getSampler2D(inInfo);\n    case 3:\n      return getSampler3D(inInfo);\n    case 4:\n      return getSampler4D(inInfo);\n    case 5:\n      return getSampler5D(inInfo);\n    default:\n      throw new Error(\n          `${shape.length}-D input sampling` +\n          ` is not yet supported`);\n  }\n}\n\nfunction getInputSamplingSnippet(\n    inInfo: InputInfo, outShapeInfo: ShapeInfo, broadcast: boolean): string {\n  let res = getSamplerFlat(inInfo);\n  res += getSamplerFromInInfo(inInfo);\n\n  // If input and output have matching logical shapes, add\n  // getTexNameAtOutCoord() method that samples the input\n  // textureSampler using the output coordinates.\n  if (broadcast ||\n      util.arraysEqual(\n          inInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape)) {\n    res += getSamplerAtOutputCoords(inInfo, outShapeInfo, broadcast);\n  }\n  return res;\n}\n\nfunction getOutputSamplingSnippet(\n    outShape: number[], outTexShape: [number, number]): string {\n  switch (outShape.length) {\n    case 0:\n      return getOutputScalarCoords();\n    case 1:\n      return getOutput1DCoords(outShape as [number], outTexShape);\n    case 2:\n      return getOutput2DCoords(outShape as [number, number], outTexShape);\n    case 3:\n      return getOutput3DCoords(\n          outShape as [number, number, number], outTexShape);\n    case 4:\n      return getOutput4DCoords(\n          outShape as [number, number, number, number], outTexShape);\n    case 5:\n      return getOutput5DCoords(\n          outShape as [number, number, number, number, number], outTexShape);\n    default:\n      throw new Error(\n          `${outShape.length}-D output sampling is not yet supported`);\n  }\n}\n\nconst SAMPLE_1D_SNIPPET = `\nvec2 UVfrom1D(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`;\n\nconst SAMPLE_2D_SNIPPET = `\nvec2 UVfrom2D(int texNumR, int texNumC, int numC, int row, int col) {\n  int index = row * numC + col;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`;\n\nconst SAMPLE_3D_SNIPPET = `\nvec2 UVfrom3D(int texNumR, int texNumC, int stride0,\n    int stride1, int row, int col, int depth) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 + depth;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`;\n\nconst SAMPLE_4D_SNIPPET = `\nvec2 UVfrom4D(int texNumR, int texNumC, int stride0,\n    int stride1, int stride2, int row, int col, int depth,\n    int depth2) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 + depth * stride2 + depth2;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`;\n\nconst SAMPLE_5D_SNIPPET = `\nvec2 UVfrom5D(int texNumR, int texNumC, int stride0,\n    int stride1, int stride2, int stride3, int row, int col, int depth,\n    int depth2, int depth3) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 +\n              depth * stride2 + depth2 * stride3 + depth3;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`;\n\nconst FLOAT_TEXTURE_SAMPLE_SNIPPET = `\n  float sampleTexture(sampler2D textureSampler, vec2 uv) {\n    return texture2D(textureSampler, uv).r;\n  }\n`;\n\nconst FLOAT_TEXTURE_SETOUTPUT_SNIPPET = `\n  void setOutput(float val) {\n    gl_FragColor = vec4(val, 0, 0, 0);\n  }\n`;\n\nconst SHADER_PREFIX = `\n  precision highp float;\n  precision highp int;\n  varying vec2 resultUV;\n  const vec2 halfCR = vec2(0.5, 0.5);\n\n  struct ivec5\n  {\n    int x;\n    int y;\n    int z;\n    int w;\n    int u;\n  };\n\n  bool isNaN(float val) {\n    float v1 = val * val;\n    float v2 = val * val;\n    return v1 == v2 ? false : true;\n  }\n\n  bool hasNaN(vec4 values) {\n    vec4 v1 = values * values;\n    vec4 v2 = values * values;\n    return any(notEqual(v1, v2));\n  }\n\n  float getNaN(vec4 values) {\n    return dot(vec4(1), values);\n  }\n\n  int round(float value) {\n    return int(floor(value + 0.5));\n  }\n\n  int imod(int x, int y) {\n    return x - y * (x / y);\n  }\n\n  //Based on the work of Dave Hoskins\n  //https://www.shadertoy.com/view/4djSRW\n  #define HASHSCALE1 443.8975\n  float random(float seed){\n    vec2 p = resultUV * seed;\n    vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n  }\n\n  ${SAMPLE_1D_SNIPPET}\n  ${SAMPLE_2D_SNIPPET}\n  ${SAMPLE_3D_SNIPPET}\n  ${SAMPLE_4D_SNIPPET}\n  ${SAMPLE_5D_SNIPPET}\n`;\n\nfunction getOutputScalarCoords() {\n  return `\n    int getOutputCoords() {\n      return 0;\n    }\n  `;\n}\n\nfunction getOutput1DCoords(\n    shape: [number], texShape: [number, number]): string {\n  if (texShape[0] === 1) {\n    return `\n      int getOutputCoords() {\n        return int(resultUV.x * ${texShape[1]}.0);\n      }\n    `;\n  }\n  if (texShape[1] === 1) {\n    return `\n      int getOutputCoords() {\n        return int(resultUV.y * ${texShape[0]}.0);\n      }\n    `;\n  }\n  return `\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${texShape[0]}, ${texShape[1]}));\n      return resTexRC.x * ${texShape[1]} + resTexRC.y;\n    }\n  `;\n}\n\nfunction getOutput3DCoords(\n    shape: [number, number, number], texShape: [number, number]): string {\n  const stride0 = shape[1] * shape[2];\n  const stride1 = shape[2];\n  return `\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${texShape[0]}, ${texShape[1]}));\n      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n      int r = index / ${stride0};\n      index -= r * ${stride0};\n      int c = index / ${stride1};\n      int d = index - c * ${stride1};\n      return ivec3(r, c, d);\n    }\n  `;\n}\n\nfunction getOutput4DCoords(\n    shape: [number, number, number, number],\n    texShape: [number, number]): string {\n  const stride2 = shape[3];\n  const stride1 = shape[2] * stride2;\n  const stride0 = shape[1] * stride1;\n  return `\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${texShape[0]}, ${texShape[1]}));\n      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n\n      int r = index / ${stride0};\n      index -= r * ${stride0};\n\n      int c = index / ${stride1};\n      index -= c * ${stride1};\n\n      int d = index / ${stride2};\n      int d2 = index - d * ${stride2};\n\n      return ivec4(r, c, d, d2);\n    }\n  `;\n}\n\nfunction getOutput5DCoords(\n    shape: [number, number, number, number, number],\n    texShape: [number, number]): string {\n  const stride3 = shape[4];\n  const stride2 = shape[3] * stride3;\n  const stride1 = shape[2] * stride2;\n  const stride0 = shape[1] * stride1;\n  return `\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${texShape[0]},\n                             ${texShape[1]}));\n\n      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n\n      int r = index / ${stride0};\n      index -= r * ${stride0};\n\n      int c = index / ${stride1};\n      index -= c * ${stride1};\n\n      int d = index / ${stride2};\n      index -= d * ${stride2};\n\n      int d2 = index  / ${stride3};\n      int d3 = index - d2 * ${stride3};\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `;\n}\n\nfunction getOutput2DCoords(\n    shape: [number, number], texShape: [number, number]): string {\n  if (util.arraysEqual(shape, texShape)) {\n    return `\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${texShape[0]}, ${texShape[1]}));\n      }\n    `;\n  }\n  if (shape[1] === 1) {\n    return `\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${texShape[0]}, ${texShape[1]}));\n        int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `;\n  }\n  if (shape[0] === 1) {\n    return `\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${texShape[0]}, ${texShape[1]}));\n        int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `;\n  }\n  return `\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${texShape[0]}, ${texShape[1]}));\n      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n      int r = index / ${shape[1]};\n      int c = index - r * ${shape[1]};\n      return ivec2(r, c);\n    }\n  `;\n}\n\nfunction getSamplerScalar(inputInfo: InputInfo): string {\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  if (inputInfo.shapeInfo.isUniform) {\n    return `float ${funcName}() {return ${texName};}`;\n  }\n  return `\n    float ${funcName}() {\n      return sampleTexture(${texName}, halfCR);\n    }\n  `;\n}\n\nfunction getSampler1D(inputInfo: InputInfo): string {\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n\n  return `\n    float ${funcName}(int index) {\n      return ${funcName}Flat(index);\n    }\n  `;\n}\n\nfunction getSampler2D(inputInfo: InputInfo): string {\n  const shape = inputInfo.shapeInfo.logicalShape;\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n\n  const texShape = inputInfo.shapeInfo.texShape;\n  if (texShape != null && util.arraysEqual(shape, texShape)) {\n    const texNumR = texShape[0];\n    const texNumC = texShape[1];\n    return `\n    float ${funcName}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n  }\n\n  const {newShape, keptDims} = util.squeezeShape(shape);\n  const squeezedShape = newShape;\n  if (squeezedShape.length < shape.length) {\n    const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);\n    const params = ['row', 'col'];\n    return `\n      ${getSamplerFromInInfo(newInputInfo)}\n      float ${funcName}(int row, int col) {\n        return ${funcName}(${getSqueezedParams(params, keptDims)});\n      }\n    `;\n  }\n\n  if (inputInfo.shapeInfo.isUniform) {\n    return `\n      float ${funcName}(int row, int col) {\n        int index = row * ${shape[1]} + col;\n        return ${funcName}Flat(index);\n      }\n    `;\n  }\n\n  const texNumR = texShape[0];\n  const texNumC = texShape[1];\n  if (texNumC === 1) {\n    return `\n    float ${funcName}(int row, int col) {\n      int index = row * ${shape[1]} + col;\n      vec2 uv = vec2(0.5, (float(index) + 0.5) / ${texNumR}.0);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n  }\n  if (texNumR === 1) {\n    return `\n    float ${funcName}(int row, int col) {\n      int index = row * ${shape[1]} + col;\n      vec2 uv = vec2((float(index) + 0.5) / ${texNumC}.0, 0.5);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n  }\n  return `\n  float ${funcName}(int row, int col) {\n    vec2 uv = UVfrom2D(${texNumR}, ${texNumC}, ${shape[1]}, row, col);\n    return sampleTexture(${texName}, uv);\n  }\n`;\n}\n\nfunction getSampler3D(inputInfo: InputInfo): string {\n  const shape = inputInfo.shapeInfo.logicalShape;\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  const stride0 = shape[1] * shape[2];\n  const stride1 = shape[2];\n\n  const {newShape, keptDims} = util.squeezeShape(shape);\n  const squeezedShape = newShape;\n  if (squeezedShape.length < shape.length) {\n    const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);\n    const params = ['row', 'col', 'depth'];\n    return `\n        ${getSamplerFromInInfo(newInputInfo)}\n        float ${funcName}(int row, int col, int depth) {\n          return ${funcName}(${getSqueezedParams(params, keptDims)});\n        }\n      `;\n  }\n\n  if (inputInfo.shapeInfo.isUniform) {\n    return `\n      float ${funcName}(int row, int col, int depth) {\n        int index = row * ${stride0} + col * ${stride1} + depth;\n        return ${funcName}Flat(index);\n      }\n    `;\n  }\n\n  const texShape = inputInfo.shapeInfo.texShape;\n  const texNumR = texShape[0];\n  const texNumC = texShape[1];\n  if (texNumC === stride0) {\n    return `\n        float ${funcName}(int row, int col, int depth) {\n          int texR = row;\n          int texC = col * ${stride1} + depth;\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${texNumC}.0, ${texNumR}.0);\n          return sampleTexture(${texName}, uv);\n        }\n      `;\n  }\n\n  if (texNumC === stride1) {\n    return `\n    float ${funcName}(int row, int col, int depth) {\n      int texR = row * ${shape[1]} + col;\n      int texC = depth;\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n  }\n\n  return `\n      float ${funcName}(int row, int col, int depth) {\n        vec2 uv = UVfrom3D(\n            ${texNumR}, ${texNumC}, ${stride0}, ${stride1}, row, col, depth);\n        return sampleTexture(${texName}, uv);\n      }\n  `;\n}\n\nfunction getSampler4D(inputInfo: InputInfo): string {\n  const shape = inputInfo.shapeInfo.logicalShape;\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  const stride2 = shape[3];\n  const stride1 = shape[2] * stride2;\n  const stride0 = shape[1] * stride1;\n\n  const {newShape, keptDims} = util.squeezeShape(shape);\n  if (newShape.length < shape.length) {\n    const newInputInfo = squeezeInputInfo(inputInfo, newShape);\n    const params = ['row', 'col', 'depth', 'depth2'];\n    return `\n      ${getSamplerFromInInfo(newInputInfo)}\n      float ${funcName}(int row, int col, int depth, int depth2) {\n        return ${funcName}(${getSqueezedParams(params, keptDims)});\n      }\n    `;\n  }\n\n  if (inputInfo.shapeInfo.isUniform) {\n    return `\n      float ${funcName}(int row, int col, int depth, int depth2) {\n        int index = row * ${stride0} + col * ${stride1} +\n            depth * ${stride2} + depth2;\n        return ${funcName}Flat(index);\n      }\n    `;\n  }\n\n  const texShape = inputInfo.shapeInfo.texShape;\n  const texNumR = texShape[0];\n  const texNumC = texShape[1];\n  if (texNumC === stride0) {\n    return `\n      float ${funcName}(int row, int col, int depth, int depth2) {\n        int texR = row;\n        int texC = col * ${stride1} + depth * ${stride2} + depth2;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n  }\n  if (texNumC === stride2) {\n    return `\n      float ${funcName}(int row, int col, int depth, int depth2) {\n        int texR = row * ${shape[1] * shape[2]} + col * ${shape[2]} + depth;\n        int texC = depth2;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n  }\n  return `\n    float ${funcName}(int row, int col, int depth, int depth2) {\n      vec2 uv = UVfrom4D(${texNumR}, ${texNumC}, ${stride0}, ${stride1},\n          ${stride2}, row, col, depth, depth2);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n}\n\nfunction getSampler5D(inputInfo: InputInfo): string {\n  const shape = inputInfo.shapeInfo.logicalShape;\n  const texName = inputInfo.name;\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  const stride3 = shape[4];\n  const stride2 = shape[3] * stride3;\n  const stride1 = shape[2] * stride2;\n  const stride0 = shape[1] * stride1;\n\n  const {newShape, keptDims} = util.squeezeShape(shape);\n  if (newShape.length < shape.length) {\n    const newInputInfo = squeezeInputInfo(inputInfo, newShape);\n    const params = ['row', 'col', 'depth', 'depth2', 'depth3'];\n    return `\n      ${getSamplerFromInInfo(newInputInfo)}\n      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n        return ${funcName}(${getSqueezedParams(params, keptDims)});\n      }\n    `;\n  }\n\n  if (inputInfo.shapeInfo.isUniform) {\n    return `\n      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n        int index = row * ${stride0} + col * ${stride1} +\n            depth * ${stride2} + depth2 * ${stride3} + depth3;\n        return ${funcName}Flat(index);\n      }\n    `;\n  }\n\n  const texShape = inputInfo.shapeInfo.texShape;\n  const texNumR = texShape[0];\n  const texNumC = texShape[1];\n\n  if (texNumC === stride0) {\n    return `\n      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        int texC = col * ${stride1} + depth * ${stride2} +\n                   depth2 * ${stride3} + depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n  }\n\n  if (texNumC === stride3) {\n    return `\n      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row * ${shape[1] * shape[2]} + col * ${shape[2]} +\n                   depth * ${shape[3]} + depth2;\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n  }\n\n  return `\n    float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n      vec2 uv = UVfrom5D(${texNumR}, ${texNumC}, ${stride0}, ${stride1},\n          ${stride2}, ${stride3}, row, col, depth, depth2, depth3);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n}\n\nfunction getSamplerFlat(inputInfo: InputInfo): string {\n  const texName = inputInfo.name;\n  const funcName =\n      'get' + texName.charAt(0).toUpperCase() + texName.slice(1) + 'Flat';\n  const inSize = util.sizeFromShape(inputInfo.shapeInfo.logicalShape);\n\n  if (inputInfo.shapeInfo.isUniform) {\n    if (inSize === 1) {\n      return `float ${funcName}(int index) {return ${texName};}`;\n    }\n    return `\n      float ${funcName}(int index) {\n        for (int i = 0; i < ${inSize}; i++) {\n          if (i == index) {\n            return ${texName}[i];\n          }\n        }\n      }\n    `;\n  }\n\n  const texShape = inputInfo.shapeInfo.texShape;\n  const tNumR = texShape[0];\n  const tNumC = texShape[1];\n  if (tNumC === 1 && tNumR === 1) {\n    return `\n      float ${funcName}(int index) {\n        return sampleTexture(${texName}, halfCR);\n      }\n    `;\n  }\n  if (tNumC === 1) {\n    return `\n      float ${funcName}(int index) {\n        vec2 uv = vec2(0.5, (float(index) + 0.5) / ${tNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n  }\n  if (tNumR === 1) {\n    return `\n      float ${funcName}(int index) {\n        vec2 uv = vec2((float(index) + 0.5) / ${tNumC}.0, 0.5);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n  }\n  return `\n    float ${funcName}(int index) {\n      vec2 uv = UVfrom1D(${tNumR}, ${tNumC}, index);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n}\n\nfunction getBroadcastOutputCoordsSampler(\n    inputInfo: InputInfo, outShapeInfo: ShapeInfo, texFuncSnippet: string,\n    funcName: string): string {\n  const inRank = inputInfo.shapeInfo.logicalShape.length;\n  const outRank = outShapeInfo.logicalShape.length;\n\n  let type = 'int';\n  if (outRank === 2) {\n    type = 'ivec2';\n  } else if (outRank === 3) {\n    type = 'ivec3';\n  } else if (outRank === 4) {\n    type = 'ivec4';\n  }\n  const broadcastDims = broadcast_util.getBroadcastDims(\n      inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);\n  const rankDiff = outRank - inRank;\n  let coordsSnippet: string;\n  if (inRank === 0) {\n    coordsSnippet = '';\n  } else if (outRank < 2 && broadcastDims.length >= 1) {\n    coordsSnippet = 'coords = 0;';\n  } else {\n    coordsSnippet =\n        broadcastDims.map(d => `coords[${d + rankDiff}] = 0;`).join('\\n');\n  }\n  let unpackedCoordsSnippet = '';\n  if (outRank < 2 && inRank > 0) {\n    unpackedCoordsSnippet = 'coords';\n  } else {\n    unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape\n                                .map((s, i) => `coords[${i + rankDiff}]`)\n                                .join(', ');\n  }\n  return `\n    float ${funcName}() {\n      ${type} coords = getOutputCoords();\n      ${coordsSnippet}\n      return get${texFuncSnippet}(${unpackedCoordsSnippet});\n    }\n  `;\n}\n\nfunction getSamplerAtOutputCoords(\n    inputInfo: InputInfo, outShapeInfo: ShapeInfo,\n    supportsBroadcasting: boolean) {\n  const texName = inputInfo.name;\n  const texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);\n  const funcName = 'get' + texFuncSnippet + 'AtOutCoords';\n\n  const broadcastDims = broadcast_util.getBroadcastDims(\n      inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);\n  const inRank = inputInfo.shapeInfo.logicalShape.length;\n  const outRank = outShapeInfo.logicalShape.length;\n  const doBroadcast =\n      supportsBroadcasting && ((outRank > inRank) || broadcastDims.length > 0);\n  const broadcastOverOuter =\n      broadcast_util.broadcastDimsAreOuter(broadcastDims);\n  const isUniform = inputInfo.shapeInfo.isUniform;\n\n  if (doBroadcast && !broadcastOverOuter) {\n    return getBroadcastOutputCoordsSampler(\n        inputInfo, outShapeInfo, texFuncSnippet, funcName);\n  }\n\n  const inSize = util.sizeFromShape(inputInfo.shapeInfo.logicalShape);\n  let broadcastSnippet = '';\n  if (doBroadcast && broadcastOverOuter) {\n    broadcastSnippet = `\n        int mainPart = index / ${inSize};\n        index -= mainPart * ${inSize};\n      `;\n  }\n\n  const outTexShape = outShapeInfo.texShape;\n  if (isUniform) {\n    if (inSize === 1) {\n      return `float ${funcName}() {return ${texName};}`;\n    }\n    return `\n      float ${funcName}() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                              vec2(${outTexShape[0]}, ${outTexShape[1]}));\n        int index = resTexRC.x * ${outTexShape[1]} + resTexRC.y;\n        ${broadcastSnippet}\n        return get${texFuncSnippet}Flat(index);\n      }\n    `;\n  }\n\n  // At this point, the input is not a uniform.\n  const inTexShape = inputInfo.shapeInfo.texShape;\n  if (util.arraysEqual(inTexShape, outTexShape)) {\n    return `\n      float ${funcName}() {\n        return sampleTexture(${texName}, resultUV);\n      }\n    `;\n  }\n\n  return `\n    float ${funcName}() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${outTexShape[0]}, ${outTexShape[1]}));\n      int index = resTexRC.x * ${outTexShape[1]} + resTexRC.y;\n      ${broadcastSnippet}\n      int texR = index / ${inTexShape[1]};\n      int texC = index - texR * ${inTexShape[1]};\n      vec2 uv = (vec2(texC, texR) + halfCR) /\n                 vec2(${inTexShape[1]}.0, ${inTexShape[0]}.0);\n\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n}\n\nexport function getCoordsDataType(rank: number): string {\n  if (rank <= 1) {\n    return 'int';\n  } else if (rank === 2) {\n    return 'ivec2';\n  } else if (rank === 3) {\n    return 'ivec3';\n  } else if (rank === 4) {\n    return 'ivec4';\n  } else if (rank === 5) {\n    return 'ivec5';\n  } else {\n    throw Error(`GPU for rank ${rank} is not yet supported`);\n  }\n}\n\n/** Returns a new input info (a copy) that has a squeezed logical shape. */\nfunction squeezeInputInfo(\n    inInfo: InputInfo, squeezedShape: number[]): InputInfo {\n  // Deep copy.\n  const newInputInfo: InputInfo = JSON.parse(JSON.stringify(inInfo));\n  newInputInfo.shapeInfo.logicalShape = squeezedShape;\n  return newInputInfo;\n}\n\nfunction getSqueezedParams(params: string[], keptDims: number[]): string {\n  return keptDims.map(d => params[d]).join(', ');\n}\n"]}},"hash":"ef5cbb0f74fe1057d6aba043705a9a77","cacheData":{"env":{}}}