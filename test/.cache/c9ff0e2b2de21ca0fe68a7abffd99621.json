{"dependencies":[{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/float16/tfjs-core/test/package.json","includedInParent":true,"mtime":1528810356568},{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/float16/tfjs-core/test/.babelrc","includedInParent":true,"mtime":1525096773813},{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/float16/tfjs-core/tsconfig.json","includedInParent":true,"mtime":1528810356568},{"name":"../doc","loc":{"line":9,"column":20}},{"name":"../environment","loc":{"line":10,"column":28}},{"name":"../util","loc":{"line":11,"column":19}},{"name":"./axis_util","loc":{"line":12,"column":24}},{"name":"./operation","loc":{"line":13,"column":26}}],"generated":{"js":"\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar doc_1 = require(\"../doc\");\nvar environment_1 = require(\"../environment\");\nvar util = require(\"../util\");\nvar axis_util = require(\"./axis_util\");\nvar operation_1 = require(\"./operation\");\nvar TransposeOps = (function () {\n    function TransposeOps() {\n    }\n    TransposeOps.transpose = function (x, perm) {\n        util.assertArgumentsAreTensors({ x: x }, 'transpose');\n        if (perm == null) {\n            perm = x.shape.map(function (s, i) { return i; }).reverse();\n        }\n        util.assert(x.rank === perm.length, \"Error in transpose: rank of input \" + x.rank + \" \" +\n            (\"must match length of perm \" + perm + \".\"));\n        perm.forEach(function (axis) {\n            util.assert(axis >= 0 && axis < x.rank, \"All entries in 'perm' must be between 0 and \" + (x.rank - 1) +\n                (\" but got \" + perm));\n        });\n        if (x.rank <= 1) {\n            return x.clone();\n        }\n        var der = function (dy) {\n            var undoPerm = axis_util.getUndoAxesPermutation(perm);\n            return { x: function () { return dy.transpose(undoPerm); } };\n        };\n        return environment_1.ENV.engine.runKernel(function (backend) { return backend.transpose(x, perm); }, { x: x }, der);\n    };\n    __decorate([\n        doc_1.doc({ heading: 'Operations', subheading: 'Matrices' }),\n        operation_1.operation\n    ], TransposeOps, \"transpose\", null);\n    return TransposeOps;\n}());\nexports.TransposeOps = TransposeOps;\n","map":{"version":3,"file":"transpose.js","sourceRoot":"","sources":["../src/ops/transpose.ts"],"names":[],"mappings":";;;;;;;;AAiBA,8BAA2B;AAC3B,8CAAmC;AAEnC,8BAAgC;AAChC,uCAAyC;AACzC,yCAAsC;AAEtC;IAAA;IAgDA,CAAC;IA5BQ,sBAAS,GAAhB,UAAmC,CAAI,EAAE,IAAe;QACtD,IAAI,CAAC,yBAAyB,CAAC,EAAC,CAAC,GAAA,EAAC,EAAE,WAAW,CAAC,CAAC;QAEjD,EAAE,CAAC,CAAC,IAAI,IAAI,IAAI,CAAC,CAAC,CAAC;YACjB,IAAI,GAAG,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,UAAC,CAAC,EAAE,CAAC,IAAK,OAAA,CAAC,EAAD,CAAC,CAAC,CAAC,OAAO,EAAE,CAAC;QAC5C,CAAC;QACD,IAAI,CAAC,MAAM,CACP,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,MAAM,EACtB,uCAAqC,CAAC,CAAC,IAAI,MAAG;aAC1C,+BAA6B,IAAI,MAAG,CAAA,CAAC,CAAC;QAC9C,IAAI,CAAC,OAAO,CAAC,UAAA,IAAI;YACf,IAAI,CAAC,MAAM,CACP,IAAI,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC,CAAC,IAAI,EAC1B,kDAA+C,CAAC,CAAC,IAAI,GAAG,CAAC,CAAE;iBACvD,cAAY,IAAM,CAAA,CAAC,CAAC;QAC9B,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC,CAAC;YAChB,MAAM,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC;QACnB,CAAC;QAED,IAAM,GAAG,GAAG,UAAC,EAAK;YAChB,IAAM,QAAQ,GAAG,SAAS,CAAC,sBAAsB,CAAC,IAAI,CAAC,CAAC;YACxD,MAAM,CAAC,EAAC,CAAC,EAAE,cAAM,OAAA,EAAE,CAAC,SAAS,CAAC,QAAQ,CAAC,EAAtB,CAAsB,EAAC,CAAC;QAC3C,CAAC,CAAC;QACF,MAAM,CAAC,iBAAG,CAAC,MAAM,CAAC,SAAS,CACvB,UAAA,OAAO,IAAI,OAAA,OAAO,CAAC,SAAS,CAAC,CAAC,EAAE,IAAI,CAAC,EAA1B,CAA0B,EAAE,EAAC,CAAC,GAAA,EAAC,EAAE,GAAG,CAAC,CAAC;IACvD,CAAC;IA3BD;QAFC,SAAG,CAAC,EAAC,OAAO,EAAE,YAAY,EAAE,UAAU,EAAE,UAAU,EAAC,CAAC;QACpD,qBAAS;uCA4BT;IACH,mBAAC;CAAA,AAhDD,IAgDC;AAhDY,oCAAY","sourcesContent":["/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {doc} from '../doc';\nimport {ENV} from '../environment';\nimport {Tensor} from '../tensor';\nimport * as util from '../util';\nimport * as axis_util from './axis_util';\nimport {operation} from './operation';\n\nexport class TransposeOps {\n  /**\n   * Transposes the `Tensor`. Permutes the dimensions according to `perm`.\n   *\n   * The returned `Tensor`'s dimension `i` will correspond to the input\n   * dimension `perm[i]`. If `perm` is not given, it is set to `[n-1...0]`,\n   * where `n` is the rank of the input `Tensor`. Hence by default, this\n   * operation performs a regular matrix transpose on 2-D input `Tensor`s.\n   *\n   * ```js\n   * const a = tf.tensor2d([1, 2, 3, 4, 5, 6], [2, 3]);\n   *\n   * a.transpose().print();  // or tf.transpose(a)\n   * ```\n   *\n   * @param x The tensor to transpose.\n   * @param perm The permutation of the dimensions of a.\n   */\n  @doc({heading: 'Operations', subheading: 'Matrices'})\n  @operation\n  static transpose<T extends Tensor>(x: T, perm?: number[]): T {\n    util.assertArgumentsAreTensors({x}, 'transpose');\n\n    if (perm == null) {\n      perm = x.shape.map((s, i) => i).reverse();\n    }\n    util.assert(\n        x.rank === perm.length,\n        `Error in transpose: rank of input ${x.rank} ` +\n            `must match length of perm ${perm}.`);\n    perm.forEach(axis => {\n      util.assert(\n          axis >= 0 && axis < x.rank,\n          `All entries in 'perm' must be between 0 and ${x.rank - 1}` +\n              ` but got ${perm}`);\n    });\n\n    if (x.rank <= 1) {\n      return x.clone();\n    }\n\n    const der = (dy: T) => {\n      const undoPerm = axis_util.getUndoAxesPermutation(perm);\n      return {x: () => dy.transpose(undoPerm)};\n    };\n    return ENV.engine.runKernel(\n        backend => backend.transpose(x, perm), {x}, der);\n  }\n}\n"]}},"hash":"712dbbd4466ef19c4c77a14b2a2808d5","cacheData":{"env":{}}}