{"dependencies":[{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/float16/tfjs-core/test/package.json","includedInParent":true,"mtime":1528810356568},{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/float16/tfjs-core/test/.babelrc","includedInParent":true,"mtime":1525096773813},{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/float16/tfjs-core/tsconfig.json","includedInParent":true,"mtime":1528810356568}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n","map":{"version":3,"file":"backend.js","sourceRoot":"","sources":["../src/kernels/backend.ts"],"names":[],"mappings":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Conv2DInfo} from '../ops/conv_util';\n// tslint:disable-next-line:max-line-length\nimport {DataId, Tensor, Tensor1D, Tensor2D, Tensor3D, Tensor4D} from '../tensor';\nimport {DataType, Rank, ShapeMap, TypedArray} from '../types';\n\n// Required information for all backends.\nexport interface BackendTimingInfo {\n  kernelMs: number;\n}\n\nexport interface TensorStorage {\n  read(dataId: DataId): Promise<TypedArray>;\n  readSync(dataId: DataId): TypedArray;\n  disposeData(dataId: DataId): void;\n  write(dataId: DataId, values: TypedArray): void;\n  fromPixels(\n      pixels: ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement,\n      numChannels: number): Tensor3D;\n  register(dataId: DataId, shape: number[], dtype: DataType): void;\n  memory(): {unreliable: boolean;};  // Backend-specific information.\n}\n\nexport interface BackendTimer {\n  time(f: () => void): Promise<BackendTimingInfo>;\n}\n\n/**\n * The interface that defines the kernels that should be implemented when\n * adding a new backend. New backends don't need to implement every one of the\n * methods, this can be done gradually (throw an error for unimplemented\n * methods).\n */\nexport interface KernelBackend extends TensorStorage, BackendTimer {\n  matMul(a: Tensor2D, b: Tensor2D, transposeA: boolean, transposeB: boolean):\n      Tensor2D;\n\n  slice<T extends Tensor>(x: T, begin: number[], size: number[]): T;\n  stridedSlice<T extends Tensor>(\n      x: T, begin: number[], end: number[], strides: number[],\n      beginMask: number, endMask: number): T;\n  reverse<T extends Tensor>(a: T, axis: number[]): T;\n\n  // Any concat of n-dimensional tensors across any axis can be reduced to\n  // a concatenation of two-dimensional tensors across the axis 1 by first\n  // partitioning the axes of the original tensors into those less than the axis\n  // to be concatenated across and the rest. Then reshape the tensors into a\n  // two-dimensional tensor by collapsing these two sets of axes and concatenate\n  // the resulting matrices across the axis 1, finally reshaping the result to\n  // have the proper shape.\n  // This method always take a rank-2 tensor (i.e a matrix) and concatenate it\n  // along the axis 1 (\"putting them next to each other\" as opposed to\n  // \"putting them on top of one another\").\n  concat(a: Tensor2D, b: Tensor2D): Tensor2D;\n\n  neg<T extends Tensor>(a: T): T;\n\n  add(a: Tensor, b: Tensor): Tensor;\n  subtract(a: Tensor, b: Tensor): Tensor;\n  multiply(a: Tensor, b: Tensor): Tensor;\n  realDivide(a: Tensor, b: Tensor): Tensor;\n  floorDiv(a: Tensor, b: Tensor): Tensor;\n\n  sum(x: Tensor, axes: number[]): Tensor;\n\n  unsortedSegmentSum<T extends Tensor>(\n      x: T, segmentIds: Tensor1D, numSegments: number): Tensor;\n\n  argMin(x: Tensor, axis: number): Tensor;\n  argMax(x: Tensor, axis: number): Tensor;\n\n  equal(a: Tensor, b: Tensor): Tensor;\n  notEqual(a: Tensor, b: Tensor): Tensor;\n\n  less(a: Tensor, b: Tensor): Tensor;\n  lessEqual(a: Tensor, b: Tensor): Tensor;\n\n  greater(a: Tensor, b: Tensor): Tensor;\n  greaterEqual(a: Tensor, b: Tensor): Tensor;\n\n  logicalNot<T extends Tensor>(a: T): T;\n  logicalAnd(a: Tensor, b: Tensor): Tensor;\n  logicalOr(a: Tensor, b: Tensor): Tensor;\n\n  where(condition: Tensor, a: Tensor, b: Tensor, dtype: DataType): Tensor;\n\n  topKValues<T extends Tensor>(x: T, k: number): Tensor1D;\n  topKIndices(x: Tensor, k: number): Tensor1D;\n\n  min(x: Tensor, axes: number[]): Tensor;\n  minimum(a: Tensor, b: Tensor): Tensor;\n\n  mod(a: Tensor, b: Tensor): Tensor;\n\n  max(x: Tensor, axes: number[]): Tensor;\n  maximum(a: Tensor, b: Tensor): Tensor;\n\n  squaredDifference(a: Tensor, b: Tensor): Tensor;\n\n  ceil<T extends Tensor>(x: T): T;\n  floor<T extends Tensor>(x: T): T;\n  round<T extends Tensor>(x: T): T;\n\n  sign<T extends Tensor>(x: T): T;\n\n  pow<T extends Tensor>(a: T, b: Tensor): T;\n  exp<T extends Tensor>(x: T): T;\n  expm1<T extends Tensor>(x: T): T;\n  log<T extends Tensor>(x: T): T;\n  log1p<T extends Tensor>(x: T): T;\n  sqrt<T extends Tensor>(x: T): T;\n  rsqrt<T extends Tensor>(x: T): T;\n\n  square<T extends Tensor>(x: T): T;\n  reciprocal<T extends Tensor>(x: T): T;\n\n  relu<T extends Tensor>(x: T): T;\n  elu<T extends Tensor>(x: T): T;\n  eluDer<T extends Tensor>(dy: T, y: T): T;\n  selu<T extends Tensor>(x: T): T;\n  int<T extends Tensor>(x: T): T;\n\n  clip<T extends Tensor>(x: T, min: number, max: number): T;\n\n  abs<T extends Tensor>(x: T): T;\n\n  sigmoid<T extends Tensor>(x: T): T;\n\n  softplus<T extends Tensor>(x: T): T;\n\n  sin<T extends Tensor>(x: T): T;\n  cos<T extends Tensor>(x: T): T;\n  tan<T extends Tensor>(x: T): T;\n\n  asin<T extends Tensor>(x: T): T;\n  acos<T extends Tensor>(x: T): T;\n  atan<T extends Tensor>(x: T): T;\n  atan2<T extends Tensor>(a: T, b: T): T;\n\n  sinh<T extends Tensor>(x: T): T;\n  cosh<T extends Tensor>(x: T): T;\n  tanh<T extends Tensor>(x: T): T;\n\n  asinh<T extends Tensor>(x: T): T;\n  acosh<T extends Tensor>(x: T): T;\n  atanh<T extends Tensor>(x: T): T;\n\n  erf<T extends Tensor>(x: T): T;\n\n  step<T extends Tensor>(x: T, alpha: number): T;\n\n  conv2d(x: Tensor4D, filter: Tensor4D, convInfo: Conv2DInfo): Tensor4D;\n  conv2dDerInput(dy: Tensor4D, filter: Tensor4D, convInfo: Conv2DInfo):\n      Tensor4D;\n  conv2dDerFilter(x: Tensor4D, dY: Tensor4D, convInfo: Conv2DInfo): Tensor4D;\n\n  depthwiseConv2D(input: Tensor4D, filter: Tensor4D, convInfo: Conv2DInfo):\n      Tensor4D;\n  depthwiseConv2DDerInput(dy: Tensor4D, filter: Tensor4D, convInfo: Conv2DInfo):\n      Tensor4D;\n  depthwiseConv2DDerFilter(x: Tensor4D, dY: Tensor4D, convInfo: Conv2DInfo):\n      Tensor4D;\n\n  maxPool(x: Tensor4D, convInfo: Conv2DInfo): Tensor4D;\n  maxPoolBackprop(dy: Tensor4D, x: Tensor4D, y: Tensor4D, convInfo: Conv2DInfo):\n      Tensor4D;\n  avgPool(x: Tensor4D, convInfo: Conv2DInfo): Tensor4D;\n  avgPoolBackprop(dy: Tensor4D, x: Tensor4D, convInfo: Conv2DInfo): Tensor4D;\n\n  reshape<T extends Tensor, R extends Rank>(x: T, shape: ShapeMap[R]):\n      Tensor<R>;\n  cast<T extends Tensor>(x: T, dtype: DataType): T;\n\n  tile<T extends Tensor>(x: T, reps: number[]): T;\n\n  pad<T extends Tensor>(\n      x: T, paddings: Array<[number, number]>, constantValue: number): T;\n\n  transpose<T extends Tensor>(x: T, perm: number[]): T;\n\n  gather<T extends Tensor>(x: T, indices: Tensor1D, axis: number): T;\n\n  resizeBilinear(\n      x: Tensor4D, newHeight: number, newWidth: number,\n      alignCorners: boolean): Tensor4D;\n\n  resizeBilinearBackprop(dy: Tensor4D, x: Tensor4D, alignCorners: boolean):\n      Tensor4D;\n\n  resizeNearestNeighbor(\n      x: Tensor4D, newHEight: number, newWidth: number,\n      alignCorners: boolean): Tensor4D;\n\n  batchNormalization(\n      x: Tensor4D, mean: Tensor4D|Tensor1D, variance: Tensor4D|Tensor1D,\n      varianceEpsilon: number, scale?: Tensor4D|Tensor1D,\n      offset?: Tensor4D|Tensor1D): Tensor4D;\n\n  localResponseNormalization4D(\n      x: Tensor4D, radius: number, bias: number, alpha: number,\n      beta: number): Tensor4D;\n\n  multinomial(\n      logits: Tensor2D, normalized: boolean, numSamples: number,\n      seed: number): Tensor2D;\n\n  oneHot(indices: Tensor1D, depth: number, onValue: number, offValue: number):\n      Tensor2D;\n\n  cumsum(x: Tensor, axis: number, exclusive: boolean, reverse: boolean): Tensor;\n\n  dispose(): void;\n}\n"]}},"hash":"82928959637512ee817e6165ca78057f","cacheData":{"env":{}}}