{"dependencies":[{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/float16/tfjs-core/test/package.json","includedInParent":true,"mtime":1525096773813},{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/float16/tfjs-core/test/.babelrc","includedInParent":true,"mtime":1525096773813},{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/float16/tfjs-core/tsconfig.json","includedInParent":true,"mtime":1524062920943}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction getBroadcastDims(inShape, outShape) {\n    var inRank = inShape.length;\n    var dims = [];\n    for (var i = 0; i < inRank; i++) {\n        var dim = inRank - 1 - i;\n        var a = inShape[dim] || 1;\n        var b = outShape[outShape.length - 1 - i] || 1;\n        if (b > 1 && a === 1) {\n            dims.unshift(dim);\n        }\n    }\n    return dims;\n}\nexports.getBroadcastDims = getBroadcastDims;\nfunction getReductionAxes(inShape, outShape) {\n    var result = [];\n    for (var i = 0; i < outShape.length; i++) {\n        var inDim = inShape[inShape.length - i - 1];\n        var outAxis = outShape.length - i - 1;\n        var outDim = outShape[outAxis];\n        if (inDim == null || (inDim === 1 && outDim > 1)) {\n            result.unshift(outAxis);\n        }\n    }\n    return result;\n}\nexports.getReductionAxes = getReductionAxes;\nfunction broadcastDimsAreOuter(dims) {\n    for (var i = 0; i < dims.length; i++) {\n        if (dims[i] !== i) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.broadcastDimsAreOuter = broadcastDimsAreOuter;\nfunction assertAndGetBroadcastShape(shapeA, shapeB) {\n    var result = [];\n    var errMsg = \"Operands could not be broadcast together with shapes \" +\n        (shapeA + \" and \" + shapeB + \".\");\n    var l = Math.max(shapeA.length, shapeB.length);\n    for (var i = 0; i < l; i++) {\n        var a = shapeA[shapeA.length - i - 1] || 1;\n        var b = shapeB[shapeB.length - i - 1] || 1;\n        if (a > 1 && b > 1 && a !== b) {\n            throw Error(errMsg);\n        }\n        result.unshift(Math.max(a, b));\n    }\n    return result;\n}\nexports.assertAndGetBroadcastShape = assertAndGetBroadcastShape;\n","map":{"version":3,"file":"broadcast_util.js","sourceRoot":"","sources":["../src/ops/broadcast_util.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n/**\n * Returns the dimensions in the input shape that are broadcasted to\n * produce the provided output shape.\n *\n * The returned dimensions are 0-indexed and sorted. An example:\n * inShape = [4, 1, 3]\n * outShape = [5, 4, 3, 3]\n * result = [1]. Dimension 1 (2nd dimension of input) gets broadcasted 1 => 3.\n */\nexport function getBroadcastDims(\n    inShape: number[], outShape: number[]): number[] {\n  const inRank = inShape.length;\n  const dims: number[] = [];\n  for (let i = 0; i < inRank; i++) {\n    const dim = inRank - 1 - i;\n    const a = inShape[dim] || 1;\n    const b = outShape[outShape.length - 1 - i] || 1;\n    if (b > 1 && a === 1) {\n      dims.unshift(dim);\n    }\n  }\n  return dims;\n}\n\n/**\n * Returns the axes in the output space that should be reduced to produce\n * the input space.\n */\nexport function getReductionAxes(\n    inShape: number[], outShape: number[]): number[] {\n  const result: number[] = [];\n  for (let i = 0; i < outShape.length; i++) {\n    const inDim = inShape[inShape.length - i - 1];\n    const outAxis = outShape.length - i - 1;\n    const outDim = outShape[outAxis];\n    if (inDim == null || (inDim === 1 && outDim > 1)) {\n      result.unshift(outAxis);\n    }\n  }\n  return result;\n}\n\n/**\n * Given the output of `getBroadcastDims()`, returns true if the broadcasting\n * is along the outer-most dimensions of the input.\n */\nexport function broadcastDimsAreOuter(dims: number[]): boolean {\n  for (let i = 0; i < dims.length; i++) {\n    if (dims[i] !== i) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function assertAndGetBroadcastShape(\n    shapeA: number[], shapeB: number[]): number[] {\n  const result: number[] = [];\n  const errMsg = `Operands could not be broadcast together with shapes ` +\n      `${shapeA} and ${shapeB}.`;\n  const l = Math.max(shapeA.length, shapeB.length);\n\n  for (let i = 0; i < l; i++) {\n    const a = shapeA[shapeA.length - i - 1] || 1;\n    const b = shapeB[shapeB.length - i - 1] || 1;\n    if (a > 1 && b > 1 && a !== b) {\n      throw Error(errMsg);\n    }\n    result.unshift(Math.max(a, b));\n  }\n  return result;\n}\n"]}},"hash":"0a3e6d44a64e211023465db2ee47b655","cacheData":{"env":{}}}