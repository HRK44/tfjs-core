{"dependencies":[{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/float16/tfjs-core/test/package.json","includedInParent":true,"mtime":1525096773813},{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/float16/tfjs-core/test/.babelrc","includedInParent":true,"mtime":1525096773813},{"name":"/usr/local/google/home/nsthorat/deeplearnjs-clients/float16/tfjs-core/tsconfig.json","includedInParent":true,"mtime":1524062920943}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar MatMulProgram = (function () {\n    function MatMulProgram(aShape, bShape, transposeA, transposeB) {\n        if (transposeA === void 0) { transposeA = false; }\n        if (transposeB === void 0) { transposeB = false; }\n        this.variableNames = ['matrixA', 'matrixB'];\n        var outerShapeA = transposeA ? aShape[1] : aShape[0];\n        var outerShapeB = transposeB ? bShape[0] : bShape[1];\n        var sharedDim = transposeA ? aShape[0] : aShape[1];\n        this.outputShape = [outerShapeA, outerShapeB];\n        var aSnippetFromOffset = function (vec4Offset, indexVar) {\n            return transposeA ? indexVar + \" + \" + vec4Offset + \", aRow\" :\n                \"aRow, \" + indexVar + \" + \" + vec4Offset;\n        };\n        var bSnippetFromOffset = function (vec4Offset, indexVar) {\n            return transposeB ? \"bCol, \" + indexVar + \" + \" + vec4Offset :\n                indexVar + \" + \" + vec4Offset + \", bCol\";\n        };\n        var sharedDimNearestVec4 = Math.floor(sharedDim / 4) * 4;\n        var sharedDimVec4Remainder = sharedDim % 4;\n        this.userCode = \" float dotARowBCol(int aRow, int bCol) {\\n      float result = 0.0;\\n      for (int i = 0; i < \" + sharedDimNearestVec4 + \"; i += 4) {\\n        vec4 a = vec4(\\n          getMatrixA(\" + aSnippetFromOffset(0, 'i') + \"),\\n          getMatrixA(\" + aSnippetFromOffset(1, 'i') + \"),\\n          getMatrixA(\" + aSnippetFromOffset(2, 'i') + \"),\\n          getMatrixA(\" + aSnippetFromOffset(3, 'i') + \")\\n        );\\n        vec4 b = vec4(\\n          getMatrixB(\" + bSnippetFromOffset(0, 'i') + \"),\\n          getMatrixB(\" + bSnippetFromOffset(1, 'i') + \"),\\n          getMatrixB(\" + bSnippetFromOffset(2, 'i') + \"),\\n          getMatrixB(\" + bSnippetFromOffset(3, 'i') + \")\\n        );\\n\\n        result += dot(a, b);\\n      }\\n\\n      if (\" + (sharedDimVec4Remainder === 1) + \") {\\n        result += getMatrixA(\" + aSnippetFromOffset(0, sharedDimNearestVec4) + \") *\\n          getMatrixB(\" + bSnippetFromOffset(0, sharedDimNearestVec4) + \");\\n      } else if (\" + (sharedDimVec4Remainder === 2) + \") {\\n        vec2 a = vec2(\\n          getMatrixA(\" + aSnippetFromOffset(0, sharedDimNearestVec4) + \"),\\n          getMatrixA(\" + aSnippetFromOffset(1, sharedDimNearestVec4) + \")\\n        );\\n        vec2 b = vec2(\\n          getMatrixB(\" + bSnippetFromOffset(0, sharedDimNearestVec4) + \"),\\n          getMatrixB(\" + bSnippetFromOffset(1, sharedDimNearestVec4) + \")\\n        );\\n        result += dot(a, b);\\n      } else if (\" + (sharedDimVec4Remainder === 3) + \") {\\n        vec3 a = vec3(\\n          getMatrixA(\" + aSnippetFromOffset(0, sharedDimNearestVec4) + \"),\\n          getMatrixA(\" + aSnippetFromOffset(1, sharedDimNearestVec4) + \"),\\n          getMatrixA(\" + aSnippetFromOffset(2, sharedDimNearestVec4) + \")\\n        );\\n        vec3 b = vec3(\\n          getMatrixB(\" + bSnippetFromOffset(0, sharedDimNearestVec4) + \"),\\n          getMatrixB(\" + bSnippetFromOffset(1, sharedDimNearestVec4) + \"),\\n          getMatrixB(\" + bSnippetFromOffset(2, sharedDimNearestVec4) + \")\\n        );\\n        result += dot(a, b);\\n      }\\n\\n      return result;\\n    }\\n\\n    void main() {\\n      ivec2 resRC = getOutputCoords();\\n      setOutput(dotARowBCol(resRC.x, resRC.y));\\n    }\\n    \";\n    }\n    return MatMulProgram;\n}());\nexports.MatMulProgram = MatMulProgram;\n","map":{"version":3,"file":"mulmat_gpu.js","sourceRoot":"","sources":["../src/kernels/webgl/mulmat_gpu.ts"],"names":[],"mappings":";;AAmBA;IAKE,uBACI,MAAwB,EAAE,MAAwB,EAAE,UAAkB,EACtE,UAAkB;QADkC,2BAAA,EAAA,kBAAkB;QACtE,2BAAA,EAAA,kBAAkB;QANtB,kBAAa,GAAG,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC;QAOrC,IAAM,WAAW,GAAG,UAAU,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;QACvD,IAAM,WAAW,GAAG,UAAU,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;QACvD,IAAM,SAAS,GAAG,UAAU,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;QACrD,IAAI,CAAC,WAAW,GAAG,CAAC,WAAW,EAAE,WAAW,CAAC,CAAC;QAE9C,IAAM,kBAAkB,GAAG,UAAC,UAAkB,EAAE,QAAuB;YACnE,OAAA,UAAU,CAAC,CAAC,CAAI,QAAQ,WAAM,UAAU,WAAQ,CAAC,CAAC;gBACrC,WAAS,QAAQ,WAAM,UAAY;QADhD,CACgD,CAAC;QACrD,IAAM,kBAAkB,GAAG,UAAC,UAAkB,EAAE,QAAuB;YACnE,OAAA,UAAU,CAAC,CAAC,CAAC,WAAS,QAAQ,WAAM,UAAY,CAAC,CAAC;gBAClC,QAAQ,WAAM,UAAU,WAAQ;QADhD,CACgD,CAAC;QAErD,IAAM,oBAAoB,GAAG,IAAI,CAAC,KAAK,CAAC,SAAS,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;QAC3D,IAAM,sBAAsB,GAAG,SAAS,GAAG,CAAC,CAAC;QAE7C,IAAI,CAAC,QAAQ,GAAG,oGAEQ,oBAAoB,kEAEzB,kBAAkB,CAAC,CAAC,EAAE,GAAG,CAAC,iCAC1B,kBAAkB,CAAC,CAAC,EAAE,GAAG,CAAC,iCAC1B,kBAAkB,CAAC,CAAC,EAAE,GAAG,CAAC,iCAC1B,kBAAkB,CAAC,CAAC,EAAE,GAAG,CAAC,oEAG1B,kBAAkB,CAAC,CAAC,EAAE,GAAG,CAAC,iCAC1B,kBAAkB,CAAC,CAAC,EAAE,GAAG,CAAC,iCAC1B,kBAAkB,CAAC,CAAC,EAAE,GAAG,CAAC,iCAC1B,kBAAkB,CAAC,CAAC,EAAE,GAAG,CAAC,6EAMrC,sBAAsB,KAAK,CAAC,2CACT,kBAAkB,CAAC,CAAC,EAAE,oBAAoB,CAAC,kCACnD,kBAAkB,CAAC,CAAC,EAAE,oBAAoB,CAAC,8BAC/C,sBAAsB,KAAK,CAAC,2DAExB,kBAAkB,CAAC,CAAC,EAAE,oBAAoB,CAAC,iCAC3C,kBAAkB,CAAC,CAAC,EAAE,oBAAoB,CAAC,oEAG3C,kBAAkB,CAAC,CAAC,EAAE,oBAAoB,CAAC,iCAC3C,kBAAkB,CAAC,CAAC,EAAE,oBAAoB,CAAC,uEAG/C,sBAAsB,KAAK,CAAC,2DAExB,kBAAkB,CAAC,CAAC,EAAE,oBAAoB,CAAC,iCAC3C,kBAAkB,CAAC,CAAC,EAAE,oBAAoB,CAAC,iCAC3C,kBAAkB,CAAC,CAAC,EAAE,oBAAoB,CAAC,oEAG3C,kBAAkB,CAAC,CAAC,EAAE,oBAAoB,CAAC,iCAC3C,kBAAkB,CAAC,CAAC,EAAE,oBAAoB,CAAC,iCAC3C,kBAAkB,CAAC,CAAC,EAAE,oBAAoB,CAAC,mNAY7D,CAAC;IACJ,CAAC;IACH,oBAAC;AAAD,CAAC,AA9ED,IA8EC;AA9EY,sCAAa","sourcesContent":["/**\n * @license\n * Copyright 2017 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class MatMulProgram implements GPGPUProgram {\n  variableNames = ['matrixA', 'matrixB'];\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      aShape: [number, number], bShape: [number, number], transposeA = false,\n      transposeB = false) {\n    const outerShapeA = transposeA ? aShape[1] : aShape[0];\n    const outerShapeB = transposeB ? bShape[0] : bShape[1];\n    const sharedDim = transposeA ? aShape[0] : aShape[1];\n    this.outputShape = [outerShapeA, outerShapeB];\n\n    const aSnippetFromOffset = (vec4Offset: number, indexVar: string|number) =>\n        transposeA ? `${indexVar} + ${vec4Offset}, aRow` :\n                     `aRow, ${indexVar} + ${vec4Offset}`;\n    const bSnippetFromOffset = (vec4Offset: number, indexVar: string|number) =>\n        transposeB ? `bCol, ${indexVar} + ${vec4Offset}` :\n                     `${indexVar} + ${vec4Offset}, bCol`;\n\n    const sharedDimNearestVec4 = Math.floor(sharedDim / 4) * 4;\n    const sharedDimVec4Remainder = sharedDim % 4;\n\n    this.userCode = ` float dotARowBCol(int aRow, int bCol) {\n      float result = 0.0;\n      for (int i = 0; i < ${sharedDimNearestVec4}; i += 4) {\n        vec4 a = vec4(\n          getMatrixA(${aSnippetFromOffset(0, 'i')}),\n          getMatrixA(${aSnippetFromOffset(1, 'i')}),\n          getMatrixA(${aSnippetFromOffset(2, 'i')}),\n          getMatrixA(${aSnippetFromOffset(3, 'i')})\n        );\n        vec4 b = vec4(\n          getMatrixB(${bSnippetFromOffset(0, 'i')}),\n          getMatrixB(${bSnippetFromOffset(1, 'i')}),\n          getMatrixB(${bSnippetFromOffset(2, 'i')}),\n          getMatrixB(${bSnippetFromOffset(3, 'i')})\n        );\n\n        result += dot(a, b);\n      }\n\n      if (${sharedDimVec4Remainder === 1}) {\n        result += getMatrixA(${aSnippetFromOffset(0, sharedDimNearestVec4)}) *\n          getMatrixB(${bSnippetFromOffset(0, sharedDimNearestVec4)});\n      } else if (${sharedDimVec4Remainder === 2}) {\n        vec2 a = vec2(\n          getMatrixA(${aSnippetFromOffset(0, sharedDimNearestVec4)}),\n          getMatrixA(${aSnippetFromOffset(1, sharedDimNearestVec4)})\n        );\n        vec2 b = vec2(\n          getMatrixB(${bSnippetFromOffset(0, sharedDimNearestVec4)}),\n          getMatrixB(${bSnippetFromOffset(1, sharedDimNearestVec4)})\n        );\n        result += dot(a, b);\n      } else if (${sharedDimVec4Remainder === 3}) {\n        vec3 a = vec3(\n          getMatrixA(${aSnippetFromOffset(0, sharedDimNearestVec4)}),\n          getMatrixA(${aSnippetFromOffset(1, sharedDimNearestVec4)}),\n          getMatrixA(${aSnippetFromOffset(2, sharedDimNearestVec4)})\n        );\n        vec3 b = vec3(\n          getMatrixB(${bSnippetFromOffset(0, sharedDimNearestVec4)}),\n          getMatrixB(${bSnippetFromOffset(1, sharedDimNearestVec4)}),\n          getMatrixB(${bSnippetFromOffset(2, sharedDimNearestVec4)})\n        );\n        result += dot(a, b);\n      }\n\n      return result;\n    }\n\n    void main() {\n      ivec2 resRC = getOutputCoords();\n      setOutput(dotARowBCol(resRC.x, resRC.y));\n    }\n    `;\n  }\n}\n"]}},"hash":"9198747d28490ff6c584d3bf812b5ddd","cacheData":{"env":{}}}